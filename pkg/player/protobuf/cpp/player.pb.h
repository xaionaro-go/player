// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: player.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_player_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_player_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_player_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_player_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_player_2eproto;
namespace player {
class AudioTrack;
struct AudioTrackDefaultTypeInternal;
extern AudioTrackDefaultTypeInternal _AudioTrack_default_instance_;
class CloseReply;
struct CloseReplyDefaultTypeInternal;
extern CloseReplyDefaultTypeInternal _CloseReply_default_instance_;
class CloseRequest;
struct CloseRequestDefaultTypeInternal;
extern CloseRequestDefaultTypeInternal _CloseRequest_default_instance_;
class EndChanReply;
struct EndChanReplyDefaultTypeInternal;
extern EndChanReplyDefaultTypeInternal _EndChanReply_default_instance_;
class EndChanRequest;
struct EndChanRequestDefaultTypeInternal;
extern EndChanRequestDefaultTypeInternal _EndChanRequest_default_instance_;
class GetAudioTracksReply;
struct GetAudioTracksReplyDefaultTypeInternal;
extern GetAudioTracksReplyDefaultTypeInternal _GetAudioTracksReply_default_instance_;
class GetAudioTracksRequest;
struct GetAudioTracksRequestDefaultTypeInternal;
extern GetAudioTracksRequestDefaultTypeInternal _GetAudioTracksRequest_default_instance_;
class GetLengthReply;
struct GetLengthReplyDefaultTypeInternal;
extern GetLengthReplyDefaultTypeInternal _GetLengthReply_default_instance_;
class GetLengthRequest;
struct GetLengthRequestDefaultTypeInternal;
extern GetLengthRequestDefaultTypeInternal _GetLengthRequest_default_instance_;
class GetLinkReply;
struct GetLinkReplyDefaultTypeInternal;
extern GetLinkReplyDefaultTypeInternal _GetLinkReply_default_instance_;
class GetLinkRequest;
struct GetLinkRequestDefaultTypeInternal;
extern GetLinkRequestDefaultTypeInternal _GetLinkRequest_default_instance_;
class GetPauseReply;
struct GetPauseReplyDefaultTypeInternal;
extern GetPauseReplyDefaultTypeInternal _GetPauseReply_default_instance_;
class GetPauseRequest;
struct GetPauseRequestDefaultTypeInternal;
extern GetPauseRequestDefaultTypeInternal _GetPauseRequest_default_instance_;
class GetPositionReply;
struct GetPositionReplyDefaultTypeInternal;
extern GetPositionReplyDefaultTypeInternal _GetPositionReply_default_instance_;
class GetPositionRequest;
struct GetPositionRequestDefaultTypeInternal;
extern GetPositionRequestDefaultTypeInternal _GetPositionRequest_default_instance_;
class GetSpeedReply;
struct GetSpeedReplyDefaultTypeInternal;
extern GetSpeedReplyDefaultTypeInternal _GetSpeedReply_default_instance_;
class GetSpeedRequest;
struct GetSpeedRequestDefaultTypeInternal;
extern GetSpeedRequestDefaultTypeInternal _GetSpeedRequest_default_instance_;
class GetSubtitlesTracksReply;
struct GetSubtitlesTracksReplyDefaultTypeInternal;
extern GetSubtitlesTracksReplyDefaultTypeInternal _GetSubtitlesTracksReply_default_instance_;
class GetSubtitlesTracksRequest;
struct GetSubtitlesTracksRequestDefaultTypeInternal;
extern GetSubtitlesTracksRequestDefaultTypeInternal _GetSubtitlesTracksRequest_default_instance_;
class GetVideoTracksReply;
struct GetVideoTracksReplyDefaultTypeInternal;
extern GetVideoTracksReplyDefaultTypeInternal _GetVideoTracksReply_default_instance_;
class GetVideoTracksRequest;
struct GetVideoTracksRequestDefaultTypeInternal;
extern GetVideoTracksRequestDefaultTypeInternal _GetVideoTracksRequest_default_instance_;
class IsEndedReply;
struct IsEndedReplyDefaultTypeInternal;
extern IsEndedReplyDefaultTypeInternal _IsEndedReply_default_instance_;
class IsEndedRequest;
struct IsEndedRequestDefaultTypeInternal;
extern IsEndedRequestDefaultTypeInternal _IsEndedRequest_default_instance_;
class OpenReply;
struct OpenReplyDefaultTypeInternal;
extern OpenReplyDefaultTypeInternal _OpenReply_default_instance_;
class OpenRequest;
struct OpenRequestDefaultTypeInternal;
extern OpenRequestDefaultTypeInternal _OpenRequest_default_instance_;
class ProcessTitleReply;
struct ProcessTitleReplyDefaultTypeInternal;
extern ProcessTitleReplyDefaultTypeInternal _ProcessTitleReply_default_instance_;
class ProcessTitleRequest;
struct ProcessTitleRequestDefaultTypeInternal;
extern ProcessTitleRequestDefaultTypeInternal _ProcessTitleRequest_default_instance_;
class SeekReply;
struct SeekReplyDefaultTypeInternal;
extern SeekReplyDefaultTypeInternal _SeekReply_default_instance_;
class SeekRequest;
struct SeekRequestDefaultTypeInternal;
extern SeekRequestDefaultTypeInternal _SeekRequest_default_instance_;
class SetAudioTrackReply;
struct SetAudioTrackReplyDefaultTypeInternal;
extern SetAudioTrackReplyDefaultTypeInternal _SetAudioTrackReply_default_instance_;
class SetAudioTrackRequest;
struct SetAudioTrackRequestDefaultTypeInternal;
extern SetAudioTrackRequestDefaultTypeInternal _SetAudioTrackRequest_default_instance_;
class SetPauseReply;
struct SetPauseReplyDefaultTypeInternal;
extern SetPauseReplyDefaultTypeInternal _SetPauseReply_default_instance_;
class SetPauseRequest;
struct SetPauseRequestDefaultTypeInternal;
extern SetPauseRequestDefaultTypeInternal _SetPauseRequest_default_instance_;
class SetSpeedReply;
struct SetSpeedReplyDefaultTypeInternal;
extern SetSpeedReplyDefaultTypeInternal _SetSpeedReply_default_instance_;
class SetSpeedRequest;
struct SetSpeedRequestDefaultTypeInternal;
extern SetSpeedRequestDefaultTypeInternal _SetSpeedRequest_default_instance_;
class SetSubtitlesTrackReply;
struct SetSubtitlesTrackReplyDefaultTypeInternal;
extern SetSubtitlesTrackReplyDefaultTypeInternal _SetSubtitlesTrackReply_default_instance_;
class SetSubtitlesTrackRequest;
struct SetSubtitlesTrackRequestDefaultTypeInternal;
extern SetSubtitlesTrackRequestDefaultTypeInternal _SetSubtitlesTrackRequest_default_instance_;
class SetVideoTrackReply;
struct SetVideoTrackReplyDefaultTypeInternal;
extern SetVideoTrackReplyDefaultTypeInternal _SetVideoTrackReply_default_instance_;
class SetVideoTrackRequest;
struct SetVideoTrackRequestDefaultTypeInternal;
extern SetVideoTrackRequestDefaultTypeInternal _SetVideoTrackRequest_default_instance_;
class SetupForStreamingReply;
struct SetupForStreamingReplyDefaultTypeInternal;
extern SetupForStreamingReplyDefaultTypeInternal _SetupForStreamingReply_default_instance_;
class SetupForStreamingRequest;
struct SetupForStreamingRequestDefaultTypeInternal;
extern SetupForStreamingRequestDefaultTypeInternal _SetupForStreamingRequest_default_instance_;
class StopReply;
struct StopReplyDefaultTypeInternal;
extern StopReplyDefaultTypeInternal _StopReply_default_instance_;
class StopRequest;
struct StopRequestDefaultTypeInternal;
extern StopRequestDefaultTypeInternal _StopRequest_default_instance_;
class SubtitlesTrack;
struct SubtitlesTrackDefaultTypeInternal;
extern SubtitlesTrackDefaultTypeInternal _SubtitlesTrack_default_instance_;
class VideoTrack;
struct VideoTrackDefaultTypeInternal;
extern VideoTrackDefaultTypeInternal _VideoTrack_default_instance_;
}  // namespace player
PROTOBUF_NAMESPACE_OPEN
template<> ::player::AudioTrack* Arena::CreateMaybeMessage<::player::AudioTrack>(Arena*);
template<> ::player::CloseReply* Arena::CreateMaybeMessage<::player::CloseReply>(Arena*);
template<> ::player::CloseRequest* Arena::CreateMaybeMessage<::player::CloseRequest>(Arena*);
template<> ::player::EndChanReply* Arena::CreateMaybeMessage<::player::EndChanReply>(Arena*);
template<> ::player::EndChanRequest* Arena::CreateMaybeMessage<::player::EndChanRequest>(Arena*);
template<> ::player::GetAudioTracksReply* Arena::CreateMaybeMessage<::player::GetAudioTracksReply>(Arena*);
template<> ::player::GetAudioTracksRequest* Arena::CreateMaybeMessage<::player::GetAudioTracksRequest>(Arena*);
template<> ::player::GetLengthReply* Arena::CreateMaybeMessage<::player::GetLengthReply>(Arena*);
template<> ::player::GetLengthRequest* Arena::CreateMaybeMessage<::player::GetLengthRequest>(Arena*);
template<> ::player::GetLinkReply* Arena::CreateMaybeMessage<::player::GetLinkReply>(Arena*);
template<> ::player::GetLinkRequest* Arena::CreateMaybeMessage<::player::GetLinkRequest>(Arena*);
template<> ::player::GetPauseReply* Arena::CreateMaybeMessage<::player::GetPauseReply>(Arena*);
template<> ::player::GetPauseRequest* Arena::CreateMaybeMessage<::player::GetPauseRequest>(Arena*);
template<> ::player::GetPositionReply* Arena::CreateMaybeMessage<::player::GetPositionReply>(Arena*);
template<> ::player::GetPositionRequest* Arena::CreateMaybeMessage<::player::GetPositionRequest>(Arena*);
template<> ::player::GetSpeedReply* Arena::CreateMaybeMessage<::player::GetSpeedReply>(Arena*);
template<> ::player::GetSpeedRequest* Arena::CreateMaybeMessage<::player::GetSpeedRequest>(Arena*);
template<> ::player::GetSubtitlesTracksReply* Arena::CreateMaybeMessage<::player::GetSubtitlesTracksReply>(Arena*);
template<> ::player::GetSubtitlesTracksRequest* Arena::CreateMaybeMessage<::player::GetSubtitlesTracksRequest>(Arena*);
template<> ::player::GetVideoTracksReply* Arena::CreateMaybeMessage<::player::GetVideoTracksReply>(Arena*);
template<> ::player::GetVideoTracksRequest* Arena::CreateMaybeMessage<::player::GetVideoTracksRequest>(Arena*);
template<> ::player::IsEndedReply* Arena::CreateMaybeMessage<::player::IsEndedReply>(Arena*);
template<> ::player::IsEndedRequest* Arena::CreateMaybeMessage<::player::IsEndedRequest>(Arena*);
template<> ::player::OpenReply* Arena::CreateMaybeMessage<::player::OpenReply>(Arena*);
template<> ::player::OpenRequest* Arena::CreateMaybeMessage<::player::OpenRequest>(Arena*);
template<> ::player::ProcessTitleReply* Arena::CreateMaybeMessage<::player::ProcessTitleReply>(Arena*);
template<> ::player::ProcessTitleRequest* Arena::CreateMaybeMessage<::player::ProcessTitleRequest>(Arena*);
template<> ::player::SeekReply* Arena::CreateMaybeMessage<::player::SeekReply>(Arena*);
template<> ::player::SeekRequest* Arena::CreateMaybeMessage<::player::SeekRequest>(Arena*);
template<> ::player::SetAudioTrackReply* Arena::CreateMaybeMessage<::player::SetAudioTrackReply>(Arena*);
template<> ::player::SetAudioTrackRequest* Arena::CreateMaybeMessage<::player::SetAudioTrackRequest>(Arena*);
template<> ::player::SetPauseReply* Arena::CreateMaybeMessage<::player::SetPauseReply>(Arena*);
template<> ::player::SetPauseRequest* Arena::CreateMaybeMessage<::player::SetPauseRequest>(Arena*);
template<> ::player::SetSpeedReply* Arena::CreateMaybeMessage<::player::SetSpeedReply>(Arena*);
template<> ::player::SetSpeedRequest* Arena::CreateMaybeMessage<::player::SetSpeedRequest>(Arena*);
template<> ::player::SetSubtitlesTrackReply* Arena::CreateMaybeMessage<::player::SetSubtitlesTrackReply>(Arena*);
template<> ::player::SetSubtitlesTrackRequest* Arena::CreateMaybeMessage<::player::SetSubtitlesTrackRequest>(Arena*);
template<> ::player::SetVideoTrackReply* Arena::CreateMaybeMessage<::player::SetVideoTrackReply>(Arena*);
template<> ::player::SetVideoTrackRequest* Arena::CreateMaybeMessage<::player::SetVideoTrackRequest>(Arena*);
template<> ::player::SetupForStreamingReply* Arena::CreateMaybeMessage<::player::SetupForStreamingReply>(Arena*);
template<> ::player::SetupForStreamingRequest* Arena::CreateMaybeMessage<::player::SetupForStreamingRequest>(Arena*);
template<> ::player::StopReply* Arena::CreateMaybeMessage<::player::StopReply>(Arena*);
template<> ::player::StopRequest* Arena::CreateMaybeMessage<::player::StopRequest>(Arena*);
template<> ::player::SubtitlesTrack* Arena::CreateMaybeMessage<::player::SubtitlesTrack>(Arena*);
template<> ::player::VideoTrack* Arena::CreateMaybeMessage<::player::VideoTrack>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace player {

enum LoggingLevel : int {
  LoggingLevelNone = 0,
  LoggingLevelFatal = 1,
  LoggingLevelPanic = 2,
  LoggingLevelError = 3,
  LoggingLevelWarn = 4,
  LoggingLevelInfo = 5,
  LoggingLevelDebug = 6,
  LoggingLevelTrace = 7,
  LoggingLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoggingLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoggingLevel_IsValid(int value);
constexpr LoggingLevel LoggingLevel_MIN = LoggingLevelNone;
constexpr LoggingLevel LoggingLevel_MAX = LoggingLevelTrace;
constexpr int LoggingLevel_ARRAYSIZE = LoggingLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoggingLevel_descriptor();
template<typename T>
inline const std::string& LoggingLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoggingLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoggingLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoggingLevel_descriptor(), enum_t_value);
}
inline bool LoggingLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoggingLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoggingLevel>(
    LoggingLevel_descriptor(), name, value);
}
// ===================================================================

class SetupForStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SetupForStreamingRequest) */ {
 public:
  inline SetupForStreamingRequest() : SetupForStreamingRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetupForStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupForStreamingRequest(const SetupForStreamingRequest& from);
  SetupForStreamingRequest(SetupForStreamingRequest&& from) noexcept
    : SetupForStreamingRequest() {
    *this = ::std::move(from);
  }

  inline SetupForStreamingRequest& operator=(const SetupForStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupForStreamingRequest& operator=(SetupForStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupForStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupForStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const SetupForStreamingRequest*>(
               &_SetupForStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SetupForStreamingRequest& a, SetupForStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupForStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupForStreamingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetupForStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetupForStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetupForStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetupForStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetupForStreamingRequest";
  }
  protected:
  explicit SetupForStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SetupForStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetupForStreamingReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SetupForStreamingReply) */ {
 public:
  inline SetupForStreamingReply() : SetupForStreamingReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetupForStreamingReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupForStreamingReply(const SetupForStreamingReply& from);
  SetupForStreamingReply(SetupForStreamingReply&& from) noexcept
    : SetupForStreamingReply() {
    *this = ::std::move(from);
  }

  inline SetupForStreamingReply& operator=(const SetupForStreamingReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupForStreamingReply& operator=(SetupForStreamingReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupForStreamingReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupForStreamingReply* internal_default_instance() {
    return reinterpret_cast<const SetupForStreamingReply*>(
               &_SetupForStreamingReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetupForStreamingReply& a, SetupForStreamingReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupForStreamingReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupForStreamingReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetupForStreamingReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetupForStreamingReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetupForStreamingReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetupForStreamingReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetupForStreamingReply";
  }
  protected:
  explicit SetupForStreamingReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SetupForStreamingReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class ProcessTitleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.ProcessTitleRequest) */ {
 public:
  inline ProcessTitleRequest() : ProcessTitleRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ProcessTitleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessTitleRequest(const ProcessTitleRequest& from);
  ProcessTitleRequest(ProcessTitleRequest&& from) noexcept
    : ProcessTitleRequest() {
    *this = ::std::move(from);
  }

  inline ProcessTitleRequest& operator=(const ProcessTitleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessTitleRequest& operator=(ProcessTitleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessTitleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessTitleRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessTitleRequest*>(
               &_ProcessTitleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProcessTitleRequest& a, ProcessTitleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessTitleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessTitleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessTitleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessTitleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ProcessTitleRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ProcessTitleRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.ProcessTitleRequest";
  }
  protected:
  explicit ProcessTitleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.ProcessTitleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class ProcessTitleReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.ProcessTitleReply) */ {
 public:
  inline ProcessTitleReply() : ProcessTitleReply(nullptr) {}
  ~ProcessTitleReply() override;
  explicit PROTOBUF_CONSTEXPR ProcessTitleReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessTitleReply(const ProcessTitleReply& from);
  ProcessTitleReply(ProcessTitleReply&& from) noexcept
    : ProcessTitleReply() {
    *this = ::std::move(from);
  }

  inline ProcessTitleReply& operator=(const ProcessTitleReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessTitleReply& operator=(ProcessTitleReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessTitleReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessTitleReply* internal_default_instance() {
    return reinterpret_cast<const ProcessTitleReply*>(
               &_ProcessTitleReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcessTitleReply& a, ProcessTitleReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessTitleReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessTitleReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessTitleReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessTitleReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessTitleReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessTitleReply& from) {
    ProcessTitleReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessTitleReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.ProcessTitleReply";
  }
  protected:
  explicit ProcessTitleReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:player.ProcessTitleReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class OpenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.OpenRequest) */ {
 public:
  inline OpenRequest() : OpenRequest(nullptr) {}
  ~OpenRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenRequest(const OpenRequest& from);
  OpenRequest(OpenRequest&& from) noexcept
    : OpenRequest() {
    *this = ::std::move(from);
  }

  inline OpenRequest& operator=(const OpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenRequest& operator=(OpenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenRequest* internal_default_instance() {
    return reinterpret_cast<const OpenRequest*>(
               &_OpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OpenRequest& a, OpenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenRequest& from) {
    OpenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.OpenRequest";
  }
  protected:
  explicit OpenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 1,
    kTitleFieldNumber = 2,
    kLoggingLevelFieldNumber = 3,
  };
  // string link = 1;
  void clear_link();
  const std::string& link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link();
  PROTOBUF_NODISCARD std::string* release_link();
  void set_allocated_link(std::string* link);
  private:
  const std::string& _internal_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
  std::string* _internal_mutable_link();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // .player.LoggingLevel loggingLevel = 3;
  void clear_logginglevel();
  ::player::LoggingLevel logginglevel() const;
  void set_logginglevel(::player::LoggingLevel value);
  private:
  ::player::LoggingLevel _internal_logginglevel() const;
  void _internal_set_logginglevel(::player::LoggingLevel value);
  public:

  // @@protoc_insertion_point(class_scope:player.OpenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    int logginglevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class OpenReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.OpenReply) */ {
 public:
  inline OpenReply() : OpenReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR OpenReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenReply(const OpenReply& from);
  OpenReply(OpenReply&& from) noexcept
    : OpenReply() {
    *this = ::std::move(from);
  }

  inline OpenReply& operator=(const OpenReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenReply& operator=(OpenReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenReply* internal_default_instance() {
    return reinterpret_cast<const OpenReply*>(
               &_OpenReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OpenReply& a, OpenReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OpenReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OpenReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.OpenReply";
  }
  protected:
  explicit OpenReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.OpenReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetLinkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetLinkRequest) */ {
 public:
  inline GetLinkRequest() : GetLinkRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetLinkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLinkRequest(const GetLinkRequest& from);
  GetLinkRequest(GetLinkRequest&& from) noexcept
    : GetLinkRequest() {
    *this = ::std::move(from);
  }

  inline GetLinkRequest& operator=(const GetLinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLinkRequest& operator=(GetLinkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLinkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLinkRequest* internal_default_instance() {
    return reinterpret_cast<const GetLinkRequest*>(
               &_GetLinkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetLinkRequest& a, GetLinkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLinkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLinkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLinkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLinkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLinkRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLinkRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetLinkRequest";
  }
  protected:
  explicit GetLinkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetLinkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetLinkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetLinkReply) */ {
 public:
  inline GetLinkReply() : GetLinkReply(nullptr) {}
  ~GetLinkReply() override;
  explicit PROTOBUF_CONSTEXPR GetLinkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLinkReply(const GetLinkReply& from);
  GetLinkReply(GetLinkReply&& from) noexcept
    : GetLinkReply() {
    *this = ::std::move(from);
  }

  inline GetLinkReply& operator=(const GetLinkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLinkReply& operator=(GetLinkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLinkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLinkReply* internal_default_instance() {
    return reinterpret_cast<const GetLinkReply*>(
               &_GetLinkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetLinkReply& a, GetLinkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLinkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLinkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLinkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLinkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLinkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLinkReply& from) {
    GetLinkReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLinkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetLinkReply";
  }
  protected:
  explicit GetLinkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 1,
  };
  // string link = 1;
  void clear_link();
  const std::string& link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link();
  PROTOBUF_NODISCARD std::string* release_link();
  void set_allocated_link(std::string* link);
  private:
  const std::string& _internal_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
  std::string* _internal_mutable_link();
  public:

  // @@protoc_insertion_point(class_scope:player.GetLinkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class EndChanRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.EndChanRequest) */ {
 public:
  inline EndChanRequest() : EndChanRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EndChanRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndChanRequest(const EndChanRequest& from);
  EndChanRequest(EndChanRequest&& from) noexcept
    : EndChanRequest() {
    *this = ::std::move(from);
  }

  inline EndChanRequest& operator=(const EndChanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndChanRequest& operator=(EndChanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndChanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndChanRequest* internal_default_instance() {
    return reinterpret_cast<const EndChanRequest*>(
               &_EndChanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EndChanRequest& a, EndChanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EndChanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndChanRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndChanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndChanRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EndChanRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EndChanRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.EndChanRequest";
  }
  protected:
  explicit EndChanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.EndChanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class EndChanReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.EndChanReply) */ {
 public:
  inline EndChanReply() : EndChanReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EndChanReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndChanReply(const EndChanReply& from);
  EndChanReply(EndChanReply&& from) noexcept
    : EndChanReply() {
    *this = ::std::move(from);
  }

  inline EndChanReply& operator=(const EndChanReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndChanReply& operator=(EndChanReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndChanReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndChanReply* internal_default_instance() {
    return reinterpret_cast<const EndChanReply*>(
               &_EndChanReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EndChanReply& a, EndChanReply& b) {
    a.Swap(&b);
  }
  inline void Swap(EndChanReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndChanReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndChanReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndChanReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EndChanReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EndChanReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.EndChanReply";
  }
  protected:
  explicit EndChanReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.EndChanReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class IsEndedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.IsEndedRequest) */ {
 public:
  inline IsEndedRequest() : IsEndedRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR IsEndedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsEndedRequest(const IsEndedRequest& from);
  IsEndedRequest(IsEndedRequest&& from) noexcept
    : IsEndedRequest() {
    *this = ::std::move(from);
  }

  inline IsEndedRequest& operator=(const IsEndedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsEndedRequest& operator=(IsEndedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsEndedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsEndedRequest* internal_default_instance() {
    return reinterpret_cast<const IsEndedRequest*>(
               &_IsEndedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IsEndedRequest& a, IsEndedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IsEndedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsEndedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsEndedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsEndedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const IsEndedRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const IsEndedRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.IsEndedRequest";
  }
  protected:
  explicit IsEndedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.IsEndedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class IsEndedReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.IsEndedReply) */ {
 public:
  inline IsEndedReply() : IsEndedReply(nullptr) {}
  ~IsEndedReply() override;
  explicit PROTOBUF_CONSTEXPR IsEndedReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsEndedReply(const IsEndedReply& from);
  IsEndedReply(IsEndedReply&& from) noexcept
    : IsEndedReply() {
    *this = ::std::move(from);
  }

  inline IsEndedReply& operator=(const IsEndedReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsEndedReply& operator=(IsEndedReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsEndedReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsEndedReply* internal_default_instance() {
    return reinterpret_cast<const IsEndedReply*>(
               &_IsEndedReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IsEndedReply& a, IsEndedReply& b) {
    a.Swap(&b);
  }
  inline void Swap(IsEndedReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsEndedReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsEndedReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsEndedReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsEndedReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsEndedReply& from) {
    IsEndedReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsEndedReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.IsEndedReply";
  }
  protected:
  explicit IsEndedReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsEndedFieldNumber = 1,
  };
  // bool isEnded = 1;
  void clear_isended();
  bool isended() const;
  void set_isended(bool value);
  private:
  bool _internal_isended() const;
  void _internal_set_isended(bool value);
  public:

  // @@protoc_insertion_point(class_scope:player.IsEndedReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isended_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetPositionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetPositionRequest) */ {
 public:
  inline GetPositionRequest() : GetPositionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetPositionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPositionRequest(const GetPositionRequest& from);
  GetPositionRequest(GetPositionRequest&& from) noexcept
    : GetPositionRequest() {
    *this = ::std::move(from);
  }

  inline GetPositionRequest& operator=(const GetPositionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPositionRequest& operator=(GetPositionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPositionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPositionRequest* internal_default_instance() {
    return reinterpret_cast<const GetPositionRequest*>(
               &_GetPositionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetPositionRequest& a, GetPositionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPositionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPositionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPositionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPositionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPositionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPositionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetPositionRequest";
  }
  protected:
  explicit GetPositionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetPositionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetPositionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetPositionReply) */ {
 public:
  inline GetPositionReply() : GetPositionReply(nullptr) {}
  ~GetPositionReply() override;
  explicit PROTOBUF_CONSTEXPR GetPositionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPositionReply(const GetPositionReply& from);
  GetPositionReply(GetPositionReply&& from) noexcept
    : GetPositionReply() {
    *this = ::std::move(from);
  }

  inline GetPositionReply& operator=(const GetPositionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPositionReply& operator=(GetPositionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPositionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPositionReply* internal_default_instance() {
    return reinterpret_cast<const GetPositionReply*>(
               &_GetPositionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetPositionReply& a, GetPositionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPositionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPositionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPositionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPositionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPositionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPositionReply& from) {
    GetPositionReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPositionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetPositionReply";
  }
  protected:
  explicit GetPositionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionSecsFieldNumber = 1,
  };
  // double positionSecs = 1;
  void clear_positionsecs();
  double positionsecs() const;
  void set_positionsecs(double value);
  private:
  double _internal_positionsecs() const;
  void _internal_set_positionsecs(double value);
  public:

  // @@protoc_insertion_point(class_scope:player.GetPositionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double positionsecs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetLengthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetLengthRequest) */ {
 public:
  inline GetLengthRequest() : GetLengthRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetLengthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLengthRequest(const GetLengthRequest& from);
  GetLengthRequest(GetLengthRequest&& from) noexcept
    : GetLengthRequest() {
    *this = ::std::move(from);
  }

  inline GetLengthRequest& operator=(const GetLengthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLengthRequest& operator=(GetLengthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLengthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLengthRequest* internal_default_instance() {
    return reinterpret_cast<const GetLengthRequest*>(
               &_GetLengthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetLengthRequest& a, GetLengthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLengthRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLengthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLengthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLengthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetLengthRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetLengthRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetLengthRequest";
  }
  protected:
  explicit GetLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetLengthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetLengthReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetLengthReply) */ {
 public:
  inline GetLengthReply() : GetLengthReply(nullptr) {}
  ~GetLengthReply() override;
  explicit PROTOBUF_CONSTEXPR GetLengthReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLengthReply(const GetLengthReply& from);
  GetLengthReply(GetLengthReply&& from) noexcept
    : GetLengthReply() {
    *this = ::std::move(from);
  }

  inline GetLengthReply& operator=(const GetLengthReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLengthReply& operator=(GetLengthReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLengthReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLengthReply* internal_default_instance() {
    return reinterpret_cast<const GetLengthReply*>(
               &_GetLengthReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetLengthReply& a, GetLengthReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLengthReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLengthReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetLengthReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetLengthReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLengthReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetLengthReply& from) {
    GetLengthReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLengthReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetLengthReply";
  }
  protected:
  explicit GetLengthReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthSecsFieldNumber = 1,
  };
  // double lengthSecs = 1;
  void clear_lengthsecs();
  double lengthsecs() const;
  void set_lengthsecs(double value);
  private:
  double _internal_lengthsecs() const;
  void _internal_set_lengthsecs(double value);
  public:

  // @@protoc_insertion_point(class_scope:player.GetLengthReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double lengthsecs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetSpeedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetSpeedRequest) */ {
 public:
  inline GetSpeedRequest() : GetSpeedRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetSpeedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSpeedRequest(const GetSpeedRequest& from);
  GetSpeedRequest(GetSpeedRequest&& from) noexcept
    : GetSpeedRequest() {
    *this = ::std::move(from);
  }

  inline GetSpeedRequest& operator=(const GetSpeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSpeedRequest& operator=(GetSpeedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSpeedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSpeedRequest* internal_default_instance() {
    return reinterpret_cast<const GetSpeedRequest*>(
               &_GetSpeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetSpeedRequest& a, GetSpeedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSpeedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSpeedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSpeedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSpeedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSpeedRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSpeedRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetSpeedRequest";
  }
  protected:
  explicit GetSpeedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetSpeedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetSpeedReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetSpeedReply) */ {
 public:
  inline GetSpeedReply() : GetSpeedReply(nullptr) {}
  ~GetSpeedReply() override;
  explicit PROTOBUF_CONSTEXPR GetSpeedReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSpeedReply(const GetSpeedReply& from);
  GetSpeedReply(GetSpeedReply&& from) noexcept
    : GetSpeedReply() {
    *this = ::std::move(from);
  }

  inline GetSpeedReply& operator=(const GetSpeedReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSpeedReply& operator=(GetSpeedReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSpeedReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSpeedReply* internal_default_instance() {
    return reinterpret_cast<const GetSpeedReply*>(
               &_GetSpeedReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetSpeedReply& a, GetSpeedReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSpeedReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSpeedReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSpeedReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSpeedReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSpeedReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSpeedReply& from) {
    GetSpeedReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSpeedReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetSpeedReply";
  }
  protected:
  explicit GetSpeedReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 1,
  };
  // double speed = 1;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:player.GetSpeedReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetSpeedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.SetSpeedRequest) */ {
 public:
  inline SetSpeedRequest() : SetSpeedRequest(nullptr) {}
  ~SetSpeedRequest() override;
  explicit PROTOBUF_CONSTEXPR SetSpeedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSpeedRequest(const SetSpeedRequest& from);
  SetSpeedRequest(SetSpeedRequest&& from) noexcept
    : SetSpeedRequest() {
    *this = ::std::move(from);
  }

  inline SetSpeedRequest& operator=(const SetSpeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSpeedRequest& operator=(SetSpeedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSpeedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSpeedRequest* internal_default_instance() {
    return reinterpret_cast<const SetSpeedRequest*>(
               &_SetSpeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetSpeedRequest& a, SetSpeedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSpeedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSpeedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSpeedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSpeedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSpeedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSpeedRequest& from) {
    SetSpeedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSpeedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetSpeedRequest";
  }
  protected:
  explicit SetSpeedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 1,
  };
  // double speed = 1;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:player.SetSpeedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double speed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetSpeedReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SetSpeedReply) */ {
 public:
  inline SetSpeedReply() : SetSpeedReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetSpeedReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSpeedReply(const SetSpeedReply& from);
  SetSpeedReply(SetSpeedReply&& from) noexcept
    : SetSpeedReply() {
    *this = ::std::move(from);
  }

  inline SetSpeedReply& operator=(const SetSpeedReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSpeedReply& operator=(SetSpeedReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSpeedReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSpeedReply* internal_default_instance() {
    return reinterpret_cast<const SetSpeedReply*>(
               &_SetSpeedReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SetSpeedReply& a, SetSpeedReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSpeedReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSpeedReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSpeedReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSpeedReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetSpeedReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetSpeedReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetSpeedReply";
  }
  protected:
  explicit SetSpeedReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SetSpeedReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetPauseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetPauseRequest) */ {
 public:
  inline GetPauseRequest() : GetPauseRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetPauseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPauseRequest(const GetPauseRequest& from);
  GetPauseRequest(GetPauseRequest&& from) noexcept
    : GetPauseRequest() {
    *this = ::std::move(from);
  }

  inline GetPauseRequest& operator=(const GetPauseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPauseRequest& operator=(GetPauseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPauseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPauseRequest* internal_default_instance() {
    return reinterpret_cast<const GetPauseRequest*>(
               &_GetPauseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetPauseRequest& a, GetPauseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPauseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPauseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPauseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPauseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPauseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPauseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetPauseRequest";
  }
  protected:
  explicit GetPauseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetPauseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetPauseReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetPauseReply) */ {
 public:
  inline GetPauseReply() : GetPauseReply(nullptr) {}
  ~GetPauseReply() override;
  explicit PROTOBUF_CONSTEXPR GetPauseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPauseReply(const GetPauseReply& from);
  GetPauseReply(GetPauseReply&& from) noexcept
    : GetPauseReply() {
    *this = ::std::move(from);
  }

  inline GetPauseReply& operator=(const GetPauseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPauseReply& operator=(GetPauseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPauseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPauseReply* internal_default_instance() {
    return reinterpret_cast<const GetPauseReply*>(
               &_GetPauseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetPauseReply& a, GetPauseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPauseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPauseReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPauseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPauseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPauseReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPauseReply& from) {
    GetPauseReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPauseReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetPauseReply";
  }
  protected:
  explicit GetPauseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsPausedFieldNumber = 1,
  };
  // bool isPaused = 1;
  void clear_ispaused();
  bool ispaused() const;
  void set_ispaused(bool value);
  private:
  bool _internal_ispaused() const;
  void _internal_set_ispaused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:player.GetPauseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ispaused_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetPauseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.SetPauseRequest) */ {
 public:
  inline SetPauseRequest() : SetPauseRequest(nullptr) {}
  ~SetPauseRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPauseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPauseRequest(const SetPauseRequest& from);
  SetPauseRequest(SetPauseRequest&& from) noexcept
    : SetPauseRequest() {
    *this = ::std::move(from);
  }

  inline SetPauseRequest& operator=(const SetPauseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPauseRequest& operator=(SetPauseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPauseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPauseRequest* internal_default_instance() {
    return reinterpret_cast<const SetPauseRequest*>(
               &_SetPauseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SetPauseRequest& a, SetPauseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPauseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPauseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPauseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPauseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPauseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPauseRequest& from) {
    SetPauseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPauseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetPauseRequest";
  }
  protected:
  explicit SetPauseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsPausedFieldNumber = 1,
  };
  // bool isPaused = 1;
  void clear_ispaused();
  bool ispaused() const;
  void set_ispaused(bool value);
  private:
  bool _internal_ispaused() const;
  void _internal_set_ispaused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:player.SetPauseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ispaused_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetPauseReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SetPauseReply) */ {
 public:
  inline SetPauseReply() : SetPauseReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetPauseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPauseReply(const SetPauseReply& from);
  SetPauseReply(SetPauseReply&& from) noexcept
    : SetPauseReply() {
    *this = ::std::move(from);
  }

  inline SetPauseReply& operator=(const SetPauseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPauseReply& operator=(SetPauseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPauseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPauseReply* internal_default_instance() {
    return reinterpret_cast<const SetPauseReply*>(
               &_SetPauseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SetPauseReply& a, SetPauseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPauseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPauseReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPauseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPauseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetPauseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetPauseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetPauseReply";
  }
  protected:
  explicit SetPauseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SetPauseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetVideoTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.SetVideoTrackRequest) */ {
 public:
  inline SetVideoTrackRequest() : SetVideoTrackRequest(nullptr) {}
  ~SetVideoTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR SetVideoTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVideoTrackRequest(const SetVideoTrackRequest& from);
  SetVideoTrackRequest(SetVideoTrackRequest&& from) noexcept
    : SetVideoTrackRequest() {
    *this = ::std::move(from);
  }

  inline SetVideoTrackRequest& operator=(const SetVideoTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVideoTrackRequest& operator=(SetVideoTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVideoTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVideoTrackRequest* internal_default_instance() {
    return reinterpret_cast<const SetVideoTrackRequest*>(
               &_SetVideoTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SetVideoTrackRequest& a, SetVideoTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVideoTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVideoTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVideoTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVideoTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVideoTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVideoTrackRequest& from) {
    SetVideoTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVideoTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetVideoTrackRequest";
  }
  protected:
  explicit SetVideoTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoTrackIDFieldNumber = 1,
  };
  // int64 videoTrackID = 1;
  void clear_videotrackid();
  int64_t videotrackid() const;
  void set_videotrackid(int64_t value);
  private:
  int64_t _internal_videotrackid() const;
  void _internal_set_videotrackid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:player.SetVideoTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t videotrackid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetVideoTrackReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SetVideoTrackReply) */ {
 public:
  inline SetVideoTrackReply() : SetVideoTrackReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetVideoTrackReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVideoTrackReply(const SetVideoTrackReply& from);
  SetVideoTrackReply(SetVideoTrackReply&& from) noexcept
    : SetVideoTrackReply() {
    *this = ::std::move(from);
  }

  inline SetVideoTrackReply& operator=(const SetVideoTrackReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVideoTrackReply& operator=(SetVideoTrackReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVideoTrackReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVideoTrackReply* internal_default_instance() {
    return reinterpret_cast<const SetVideoTrackReply*>(
               &_SetVideoTrackReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SetVideoTrackReply& a, SetVideoTrackReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVideoTrackReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVideoTrackReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVideoTrackReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVideoTrackReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetVideoTrackReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetVideoTrackReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetVideoTrackReply";
  }
  protected:
  explicit SetVideoTrackReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SetVideoTrackReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetAudioTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.SetAudioTrackRequest) */ {
 public:
  inline SetAudioTrackRequest() : SetAudioTrackRequest(nullptr) {}
  ~SetAudioTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR SetAudioTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAudioTrackRequest(const SetAudioTrackRequest& from);
  SetAudioTrackRequest(SetAudioTrackRequest&& from) noexcept
    : SetAudioTrackRequest() {
    *this = ::std::move(from);
  }

  inline SetAudioTrackRequest& operator=(const SetAudioTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAudioTrackRequest& operator=(SetAudioTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAudioTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAudioTrackRequest* internal_default_instance() {
    return reinterpret_cast<const SetAudioTrackRequest*>(
               &_SetAudioTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetAudioTrackRequest& a, SetAudioTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAudioTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAudioTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAudioTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAudioTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAudioTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAudioTrackRequest& from) {
    SetAudioTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAudioTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetAudioTrackRequest";
  }
  protected:
  explicit SetAudioTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioTrackIDFieldNumber = 1,
  };
  // int64 audioTrackID = 1;
  void clear_audiotrackid();
  int64_t audiotrackid() const;
  void set_audiotrackid(int64_t value);
  private:
  int64_t _internal_audiotrackid() const;
  void _internal_set_audiotrackid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:player.SetAudioTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t audiotrackid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetAudioTrackReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SetAudioTrackReply) */ {
 public:
  inline SetAudioTrackReply() : SetAudioTrackReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetAudioTrackReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAudioTrackReply(const SetAudioTrackReply& from);
  SetAudioTrackReply(SetAudioTrackReply&& from) noexcept
    : SetAudioTrackReply() {
    *this = ::std::move(from);
  }

  inline SetAudioTrackReply& operator=(const SetAudioTrackReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAudioTrackReply& operator=(SetAudioTrackReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAudioTrackReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAudioTrackReply* internal_default_instance() {
    return reinterpret_cast<const SetAudioTrackReply*>(
               &_SetAudioTrackReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetAudioTrackReply& a, SetAudioTrackReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAudioTrackReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAudioTrackReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAudioTrackReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAudioTrackReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetAudioTrackReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetAudioTrackReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetAudioTrackReply";
  }
  protected:
  explicit SetAudioTrackReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SetAudioTrackReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetSubtitlesTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.SetSubtitlesTrackRequest) */ {
 public:
  inline SetSubtitlesTrackRequest() : SetSubtitlesTrackRequest(nullptr) {}
  ~SetSubtitlesTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR SetSubtitlesTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSubtitlesTrackRequest(const SetSubtitlesTrackRequest& from);
  SetSubtitlesTrackRequest(SetSubtitlesTrackRequest&& from) noexcept
    : SetSubtitlesTrackRequest() {
    *this = ::std::move(from);
  }

  inline SetSubtitlesTrackRequest& operator=(const SetSubtitlesTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSubtitlesTrackRequest& operator=(SetSubtitlesTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSubtitlesTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSubtitlesTrackRequest* internal_default_instance() {
    return reinterpret_cast<const SetSubtitlesTrackRequest*>(
               &_SetSubtitlesTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SetSubtitlesTrackRequest& a, SetSubtitlesTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSubtitlesTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSubtitlesTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSubtitlesTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSubtitlesTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSubtitlesTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSubtitlesTrackRequest& from) {
    SetSubtitlesTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSubtitlesTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetSubtitlesTrackRequest";
  }
  protected:
  explicit SetSubtitlesTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubtitlesTrackIDFieldNumber = 1,
  };
  // int64 subtitlesTrackID = 1;
  void clear_subtitlestrackid();
  int64_t subtitlestrackid() const;
  void set_subtitlestrackid(int64_t value);
  private:
  int64_t _internal_subtitlestrackid() const;
  void _internal_set_subtitlestrackid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:player.SetSubtitlesTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t subtitlestrackid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SetSubtitlesTrackReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SetSubtitlesTrackReply) */ {
 public:
  inline SetSubtitlesTrackReply() : SetSubtitlesTrackReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetSubtitlesTrackReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSubtitlesTrackReply(const SetSubtitlesTrackReply& from);
  SetSubtitlesTrackReply(SetSubtitlesTrackReply&& from) noexcept
    : SetSubtitlesTrackReply() {
    *this = ::std::move(from);
  }

  inline SetSubtitlesTrackReply& operator=(const SetSubtitlesTrackReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSubtitlesTrackReply& operator=(SetSubtitlesTrackReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSubtitlesTrackReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSubtitlesTrackReply* internal_default_instance() {
    return reinterpret_cast<const SetSubtitlesTrackReply*>(
               &_SetSubtitlesTrackReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SetSubtitlesTrackReply& a, SetSubtitlesTrackReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSubtitlesTrackReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSubtitlesTrackReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSubtitlesTrackReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSubtitlesTrackReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetSubtitlesTrackReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetSubtitlesTrackReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SetSubtitlesTrackReply";
  }
  protected:
  explicit SetSubtitlesTrackReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SetSubtitlesTrackReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class VideoTrack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.VideoTrack) */ {
 public:
  inline VideoTrack() : VideoTrack(nullptr) {}
  ~VideoTrack() override;
  explicit PROTOBUF_CONSTEXPR VideoTrack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoTrack(const VideoTrack& from);
  VideoTrack(VideoTrack&& from) noexcept
    : VideoTrack() {
    *this = ::std::move(from);
  }

  inline VideoTrack& operator=(const VideoTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoTrack& operator=(VideoTrack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoTrack& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoTrack* internal_default_instance() {
    return reinterpret_cast<const VideoTrack*>(
               &_VideoTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VideoTrack& a, VideoTrack& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoTrack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoTrack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoTrack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoTrack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoTrack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoTrack& from) {
    VideoTrack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoTrack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.VideoTrack";
  }
  protected:
  explicit VideoTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIsActiveFieldNumber = 2,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // bool isActive = 2;
  void clear_isactive();
  bool isactive() const;
  void set_isactive(bool value);
  private:
  bool _internal_isactive() const;
  void _internal_set_isactive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:player.VideoTrack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    bool isactive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SeekRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.SeekRequest) */ {
 public:
  inline SeekRequest() : SeekRequest(nullptr) {}
  ~SeekRequest() override;
  explicit PROTOBUF_CONSTEXPR SeekRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeekRequest(const SeekRequest& from);
  SeekRequest(SeekRequest&& from) noexcept
    : SeekRequest() {
    *this = ::std::move(from);
  }

  inline SeekRequest& operator=(const SeekRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeekRequest& operator=(SeekRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeekRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeekRequest* internal_default_instance() {
    return reinterpret_cast<const SeekRequest*>(
               &_SeekRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SeekRequest& a, SeekRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SeekRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeekRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeekRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeekRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeekRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SeekRequest& from) {
    SeekRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeekRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SeekRequest";
  }
  protected:
  explicit SeekRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kIsRelativeFieldNumber = 2,
    kIsQuickFieldNumber = 3,
  };
  // int64 pos = 1;
  void clear_pos();
  int64_t pos() const;
  void set_pos(int64_t value);
  private:
  int64_t _internal_pos() const;
  void _internal_set_pos(int64_t value);
  public:

  // bool isRelative = 2;
  void clear_isrelative();
  bool isrelative() const;
  void set_isrelative(bool value);
  private:
  bool _internal_isrelative() const;
  void _internal_set_isrelative(bool value);
  public:

  // bool isQuick = 3;
  void clear_isquick();
  bool isquick() const;
  void set_isquick(bool value);
  private:
  bool _internal_isquick() const;
  void _internal_set_isquick(bool value);
  public:

  // @@protoc_insertion_point(class_scope:player.SeekRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t pos_;
    bool isrelative_;
    bool isquick_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SeekReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.SeekReply) */ {
 public:
  inline SeekReply() : SeekReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SeekReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeekReply(const SeekReply& from);
  SeekReply(SeekReply&& from) noexcept
    : SeekReply() {
    *this = ::std::move(from);
  }

  inline SeekReply& operator=(const SeekReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeekReply& operator=(SeekReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeekReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeekReply* internal_default_instance() {
    return reinterpret_cast<const SeekReply*>(
               &_SeekReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SeekReply& a, SeekReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SeekReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeekReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeekReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeekReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SeekReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SeekReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SeekReply";
  }
  protected:
  explicit SeekReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.SeekReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetVideoTracksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetVideoTracksRequest) */ {
 public:
  inline GetVideoTracksRequest() : GetVideoTracksRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetVideoTracksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVideoTracksRequest(const GetVideoTracksRequest& from);
  GetVideoTracksRequest(GetVideoTracksRequest&& from) noexcept
    : GetVideoTracksRequest() {
    *this = ::std::move(from);
  }

  inline GetVideoTracksRequest& operator=(const GetVideoTracksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVideoTracksRequest& operator=(GetVideoTracksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVideoTracksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVideoTracksRequest* internal_default_instance() {
    return reinterpret_cast<const GetVideoTracksRequest*>(
               &_GetVideoTracksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetVideoTracksRequest& a, GetVideoTracksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVideoTracksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVideoTracksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVideoTracksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVideoTracksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetVideoTracksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetVideoTracksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetVideoTracksRequest";
  }
  protected:
  explicit GetVideoTracksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetVideoTracksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetVideoTracksReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetVideoTracksReply) */ {
 public:
  inline GetVideoTracksReply() : GetVideoTracksReply(nullptr) {}
  ~GetVideoTracksReply() override;
  explicit PROTOBUF_CONSTEXPR GetVideoTracksReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVideoTracksReply(const GetVideoTracksReply& from);
  GetVideoTracksReply(GetVideoTracksReply&& from) noexcept
    : GetVideoTracksReply() {
    *this = ::std::move(from);
  }

  inline GetVideoTracksReply& operator=(const GetVideoTracksReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVideoTracksReply& operator=(GetVideoTracksReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVideoTracksReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVideoTracksReply* internal_default_instance() {
    return reinterpret_cast<const GetVideoTracksReply*>(
               &_GetVideoTracksReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetVideoTracksReply& a, GetVideoTracksReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVideoTracksReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVideoTracksReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVideoTracksReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVideoTracksReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVideoTracksReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVideoTracksReply& from) {
    GetVideoTracksReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVideoTracksReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetVideoTracksReply";
  }
  protected:
  explicit GetVideoTracksReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoTrackFieldNumber = 1,
  };
  // repeated .player.VideoTrack videoTrack = 1;
  int videotrack_size() const;
  private:
  int _internal_videotrack_size() const;
  public:
  void clear_videotrack();
  ::player::VideoTrack* mutable_videotrack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::VideoTrack >*
      mutable_videotrack();
  private:
  const ::player::VideoTrack& _internal_videotrack(int index) const;
  ::player::VideoTrack* _internal_add_videotrack();
  public:
  const ::player::VideoTrack& videotrack(int index) const;
  ::player::VideoTrack* add_videotrack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::VideoTrack >&
      videotrack() const;

  // @@protoc_insertion_point(class_scope:player.GetVideoTracksReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::VideoTrack > videotrack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class AudioTrack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.AudioTrack) */ {
 public:
  inline AudioTrack() : AudioTrack(nullptr) {}
  ~AudioTrack() override;
  explicit PROTOBUF_CONSTEXPR AudioTrack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioTrack(const AudioTrack& from);
  AudioTrack(AudioTrack&& from) noexcept
    : AudioTrack() {
    *this = ::std::move(from);
  }

  inline AudioTrack& operator=(const AudioTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioTrack& operator=(AudioTrack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioTrack& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioTrack* internal_default_instance() {
    return reinterpret_cast<const AudioTrack*>(
               &_AudioTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(AudioTrack& a, AudioTrack& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioTrack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioTrack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioTrack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioTrack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioTrack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioTrack& from) {
    AudioTrack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioTrack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.AudioTrack";
  }
  protected:
  explicit AudioTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIsActiveFieldNumber = 2,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // bool isActive = 2;
  void clear_isactive();
  bool isactive() const;
  void set_isactive(bool value);
  private:
  bool _internal_isactive() const;
  void _internal_set_isactive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:player.AudioTrack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    bool isactive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetAudioTracksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetAudioTracksRequest) */ {
 public:
  inline GetAudioTracksRequest() : GetAudioTracksRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetAudioTracksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioTracksRequest(const GetAudioTracksRequest& from);
  GetAudioTracksRequest(GetAudioTracksRequest&& from) noexcept
    : GetAudioTracksRequest() {
    *this = ::std::move(from);
  }

  inline GetAudioTracksRequest& operator=(const GetAudioTracksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioTracksRequest& operator=(GetAudioTracksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioTracksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioTracksRequest* internal_default_instance() {
    return reinterpret_cast<const GetAudioTracksRequest*>(
               &_GetAudioTracksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetAudioTracksRequest& a, GetAudioTracksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioTracksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioTracksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioTracksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioTracksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetAudioTracksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetAudioTracksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetAudioTracksRequest";
  }
  protected:
  explicit GetAudioTracksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetAudioTracksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetAudioTracksReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetAudioTracksReply) */ {
 public:
  inline GetAudioTracksReply() : GetAudioTracksReply(nullptr) {}
  ~GetAudioTracksReply() override;
  explicit PROTOBUF_CONSTEXPR GetAudioTracksReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAudioTracksReply(const GetAudioTracksReply& from);
  GetAudioTracksReply(GetAudioTracksReply&& from) noexcept
    : GetAudioTracksReply() {
    *this = ::std::move(from);
  }

  inline GetAudioTracksReply& operator=(const GetAudioTracksReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAudioTracksReply& operator=(GetAudioTracksReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAudioTracksReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAudioTracksReply* internal_default_instance() {
    return reinterpret_cast<const GetAudioTracksReply*>(
               &_GetAudioTracksReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetAudioTracksReply& a, GetAudioTracksReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAudioTracksReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAudioTracksReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAudioTracksReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAudioTracksReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAudioTracksReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAudioTracksReply& from) {
    GetAudioTracksReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAudioTracksReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetAudioTracksReply";
  }
  protected:
  explicit GetAudioTracksReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioTrackFieldNumber = 1,
  };
  // repeated .player.AudioTrack audioTrack = 1;
  int audiotrack_size() const;
  private:
  int _internal_audiotrack_size() const;
  public:
  void clear_audiotrack();
  ::player::AudioTrack* mutable_audiotrack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::AudioTrack >*
      mutable_audiotrack();
  private:
  const ::player::AudioTrack& _internal_audiotrack(int index) const;
  ::player::AudioTrack* _internal_add_audiotrack();
  public:
  const ::player::AudioTrack& audiotrack(int index) const;
  ::player::AudioTrack* add_audiotrack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::AudioTrack >&
      audiotrack() const;

  // @@protoc_insertion_point(class_scope:player.GetAudioTracksReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::AudioTrack > audiotrack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class SubtitlesTrack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.SubtitlesTrack) */ {
 public:
  inline SubtitlesTrack() : SubtitlesTrack(nullptr) {}
  ~SubtitlesTrack() override;
  explicit PROTOBUF_CONSTEXPR SubtitlesTrack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubtitlesTrack(const SubtitlesTrack& from);
  SubtitlesTrack(SubtitlesTrack&& from) noexcept
    : SubtitlesTrack() {
    *this = ::std::move(from);
  }

  inline SubtitlesTrack& operator=(const SubtitlesTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubtitlesTrack& operator=(SubtitlesTrack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubtitlesTrack& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubtitlesTrack* internal_default_instance() {
    return reinterpret_cast<const SubtitlesTrack*>(
               &_SubtitlesTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SubtitlesTrack& a, SubtitlesTrack& b) {
    a.Swap(&b);
  }
  inline void Swap(SubtitlesTrack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubtitlesTrack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubtitlesTrack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubtitlesTrack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubtitlesTrack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubtitlesTrack& from) {
    SubtitlesTrack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubtitlesTrack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.SubtitlesTrack";
  }
  protected:
  explicit SubtitlesTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIsActiveFieldNumber = 2,
  };
  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // bool isActive = 2;
  void clear_isactive();
  bool isactive() const;
  void set_isactive(bool value);
  private:
  bool _internal_isactive() const;
  void _internal_set_isactive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:player.SubtitlesTrack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    bool isactive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetSubtitlesTracksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.GetSubtitlesTracksRequest) */ {
 public:
  inline GetSubtitlesTracksRequest() : GetSubtitlesTracksRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetSubtitlesTracksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubtitlesTracksRequest(const GetSubtitlesTracksRequest& from);
  GetSubtitlesTracksRequest(GetSubtitlesTracksRequest&& from) noexcept
    : GetSubtitlesTracksRequest() {
    *this = ::std::move(from);
  }

  inline GetSubtitlesTracksRequest& operator=(const GetSubtitlesTracksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubtitlesTracksRequest& operator=(GetSubtitlesTracksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubtitlesTracksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubtitlesTracksRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubtitlesTracksRequest*>(
               &_GetSubtitlesTracksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetSubtitlesTracksRequest& a, GetSubtitlesTracksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubtitlesTracksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubtitlesTracksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubtitlesTracksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubtitlesTracksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSubtitlesTracksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSubtitlesTracksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetSubtitlesTracksRequest";
  }
  protected:
  explicit GetSubtitlesTracksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.GetSubtitlesTracksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class GetSubtitlesTracksReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:player.GetSubtitlesTracksReply) */ {
 public:
  inline GetSubtitlesTracksReply() : GetSubtitlesTracksReply(nullptr) {}
  ~GetSubtitlesTracksReply() override;
  explicit PROTOBUF_CONSTEXPR GetSubtitlesTracksReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubtitlesTracksReply(const GetSubtitlesTracksReply& from);
  GetSubtitlesTracksReply(GetSubtitlesTracksReply&& from) noexcept
    : GetSubtitlesTracksReply() {
    *this = ::std::move(from);
  }

  inline GetSubtitlesTracksReply& operator=(const GetSubtitlesTracksReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubtitlesTracksReply& operator=(GetSubtitlesTracksReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubtitlesTracksReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubtitlesTracksReply* internal_default_instance() {
    return reinterpret_cast<const GetSubtitlesTracksReply*>(
               &_GetSubtitlesTracksReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetSubtitlesTracksReply& a, GetSubtitlesTracksReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubtitlesTracksReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubtitlesTracksReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubtitlesTracksReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubtitlesTracksReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubtitlesTracksReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSubtitlesTracksReply& from) {
    GetSubtitlesTracksReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubtitlesTracksReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.GetSubtitlesTracksReply";
  }
  protected:
  explicit GetSubtitlesTracksReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubtitlesTrackFieldNumber = 1,
  };
  // repeated .player.SubtitlesTrack subtitlesTrack = 1;
  int subtitlestrack_size() const;
  private:
  int _internal_subtitlestrack_size() const;
  public:
  void clear_subtitlestrack();
  ::player::SubtitlesTrack* mutable_subtitlestrack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::SubtitlesTrack >*
      mutable_subtitlestrack();
  private:
  const ::player::SubtitlesTrack& _internal_subtitlestrack(int index) const;
  ::player::SubtitlesTrack* _internal_add_subtitlestrack();
  public:
  const ::player::SubtitlesTrack& subtitlestrack(int index) const;
  ::player::SubtitlesTrack* add_subtitlestrack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::SubtitlesTrack >&
      subtitlestrack() const;

  // @@protoc_insertion_point(class_scope:player.GetSubtitlesTracksReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::SubtitlesTrack > subtitlestrack_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class StopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.StopRequest) */ {
 public:
  inline StopRequest() : StopRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopRequest(const StopRequest& from);
  StopRequest(StopRequest&& from) noexcept
    : StopRequest() {
    *this = ::std::move(from);
  }

  inline StopRequest& operator=(const StopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopRequest& operator=(StopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopRequest* internal_default_instance() {
    return reinterpret_cast<const StopRequest*>(
               &_StopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(StopRequest& a, StopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.StopRequest";
  }
  protected:
  explicit StopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.StopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class StopReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.StopReply) */ {
 public:
  inline StopReply() : StopReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopReply(const StopReply& from);
  StopReply(StopReply&& from) noexcept
    : StopReply() {
    *this = ::std::move(from);
  }

  inline StopReply& operator=(const StopReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopReply& operator=(StopReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopReply* internal_default_instance() {
    return reinterpret_cast<const StopReply*>(
               &_StopReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(StopReply& a, StopReply& b) {
    a.Swap(&b);
  }
  inline void Swap(StopReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.StopReply";
  }
  protected:
  explicit StopReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.StopReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class CloseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.CloseRequest) */ {
 public:
  inline CloseRequest() : CloseRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CloseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseRequest(const CloseRequest& from);
  CloseRequest(CloseRequest&& from) noexcept
    : CloseRequest() {
    *this = ::std::move(from);
  }

  inline CloseRequest& operator=(const CloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseRequest& operator=(CloseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseRequest* internal_default_instance() {
    return reinterpret_cast<const CloseRequest*>(
               &_CloseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CloseRequest& a, CloseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.CloseRequest";
  }
  protected:
  explicit CloseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.CloseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// -------------------------------------------------------------------

class CloseReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:player.CloseReply) */ {
 public:
  inline CloseReply() : CloseReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CloseReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseReply(const CloseReply& from);
  CloseReply(CloseReply&& from) noexcept
    : CloseReply() {
    *this = ::std::move(from);
  }

  inline CloseReply& operator=(const CloseReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseReply& operator=(CloseReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseReply* internal_default_instance() {
    return reinterpret_cast<const CloseReply*>(
               &_CloseReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CloseReply& a, CloseReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "player.CloseReply";
  }
  protected:
  explicit CloseReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:player.CloseReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_player_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetupForStreamingRequest

// -------------------------------------------------------------------

// SetupForStreamingReply

// -------------------------------------------------------------------

// ProcessTitleRequest

// -------------------------------------------------------------------

// ProcessTitleReply

// string title = 1;
inline void ProcessTitleReply::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ProcessTitleReply::title() const {
  // @@protoc_insertion_point(field_get:player.ProcessTitleReply.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessTitleReply::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:player.ProcessTitleReply.title)
}
inline std::string* ProcessTitleReply::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:player.ProcessTitleReply.title)
  return _s;
}
inline const std::string& ProcessTitleReply::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ProcessTitleReply::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessTitleReply::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessTitleReply::release_title() {
  // @@protoc_insertion_point(field_release:player.ProcessTitleReply.title)
  return _impl_.title_.Release();
}
inline void ProcessTitleReply::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:player.ProcessTitleReply.title)
}

// -------------------------------------------------------------------

// OpenRequest

// string link = 1;
inline void OpenRequest::clear_link() {
  _impl_.link_.ClearToEmpty();
}
inline const std::string& OpenRequest::link() const {
  // @@protoc_insertion_point(field_get:player.OpenRequest.link)
  return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:player.OpenRequest.link)
}
inline std::string* OpenRequest::mutable_link() {
  std::string* _s = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:player.OpenRequest.link)
  return _s;
}
inline const std::string& OpenRequest::_internal_link() const {
  return _impl_.link_.Get();
}
inline void OpenRequest::_internal_set_link(const std::string& value) {
  
  _impl_.link_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_link() {
  
  return _impl_.link_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_link() {
  // @@protoc_insertion_point(field_release:player.OpenRequest.link)
  return _impl_.link_.Release();
}
inline void OpenRequest::set_allocated_link(std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  _impl_.link_.SetAllocated(link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_.IsDefault()) {
    _impl_.link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:player.OpenRequest.link)
}

// string title = 2;
inline void OpenRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& OpenRequest::title() const {
  // @@protoc_insertion_point(field_get:player.OpenRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:player.OpenRequest.title)
}
inline std::string* OpenRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:player.OpenRequest.title)
  return _s;
}
inline const std::string& OpenRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void OpenRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_title() {
  // @@protoc_insertion_point(field_release:player.OpenRequest.title)
  return _impl_.title_.Release();
}
inline void OpenRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:player.OpenRequest.title)
}

// .player.LoggingLevel loggingLevel = 3;
inline void OpenRequest::clear_logginglevel() {
  _impl_.logginglevel_ = 0;
}
inline ::player::LoggingLevel OpenRequest::_internal_logginglevel() const {
  return static_cast< ::player::LoggingLevel >(_impl_.logginglevel_);
}
inline ::player::LoggingLevel OpenRequest::logginglevel() const {
  // @@protoc_insertion_point(field_get:player.OpenRequest.loggingLevel)
  return _internal_logginglevel();
}
inline void OpenRequest::_internal_set_logginglevel(::player::LoggingLevel value) {
  
  _impl_.logginglevel_ = value;
}
inline void OpenRequest::set_logginglevel(::player::LoggingLevel value) {
  _internal_set_logginglevel(value);
  // @@protoc_insertion_point(field_set:player.OpenRequest.loggingLevel)
}

// -------------------------------------------------------------------

// OpenReply

// -------------------------------------------------------------------

// GetLinkRequest

// -------------------------------------------------------------------

// GetLinkReply

// string link = 1;
inline void GetLinkReply::clear_link() {
  _impl_.link_.ClearToEmpty();
}
inline const std::string& GetLinkReply::link() const {
  // @@protoc_insertion_point(field_get:player.GetLinkReply.link)
  return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetLinkReply::set_link(ArgT0&& arg0, ArgT... args) {
 
 _impl_.link_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:player.GetLinkReply.link)
}
inline std::string* GetLinkReply::mutable_link() {
  std::string* _s = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:player.GetLinkReply.link)
  return _s;
}
inline const std::string& GetLinkReply::_internal_link() const {
  return _impl_.link_.Get();
}
inline void GetLinkReply::_internal_set_link(const std::string& value) {
  
  _impl_.link_.Set(value, GetArenaForAllocation());
}
inline std::string* GetLinkReply::_internal_mutable_link() {
  
  return _impl_.link_.Mutable(GetArenaForAllocation());
}
inline std::string* GetLinkReply::release_link() {
  // @@protoc_insertion_point(field_release:player.GetLinkReply.link)
  return _impl_.link_.Release();
}
inline void GetLinkReply::set_allocated_link(std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  _impl_.link_.SetAllocated(link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.link_.IsDefault()) {
    _impl_.link_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:player.GetLinkReply.link)
}

// -------------------------------------------------------------------

// EndChanRequest

// -------------------------------------------------------------------

// EndChanReply

// -------------------------------------------------------------------

// IsEndedRequest

// -------------------------------------------------------------------

// IsEndedReply

// bool isEnded = 1;
inline void IsEndedReply::clear_isended() {
  _impl_.isended_ = false;
}
inline bool IsEndedReply::_internal_isended() const {
  return _impl_.isended_;
}
inline bool IsEndedReply::isended() const {
  // @@protoc_insertion_point(field_get:player.IsEndedReply.isEnded)
  return _internal_isended();
}
inline void IsEndedReply::_internal_set_isended(bool value) {
  
  _impl_.isended_ = value;
}
inline void IsEndedReply::set_isended(bool value) {
  _internal_set_isended(value);
  // @@protoc_insertion_point(field_set:player.IsEndedReply.isEnded)
}

// -------------------------------------------------------------------

// GetPositionRequest

// -------------------------------------------------------------------

// GetPositionReply

// double positionSecs = 1;
inline void GetPositionReply::clear_positionsecs() {
  _impl_.positionsecs_ = 0;
}
inline double GetPositionReply::_internal_positionsecs() const {
  return _impl_.positionsecs_;
}
inline double GetPositionReply::positionsecs() const {
  // @@protoc_insertion_point(field_get:player.GetPositionReply.positionSecs)
  return _internal_positionsecs();
}
inline void GetPositionReply::_internal_set_positionsecs(double value) {
  
  _impl_.positionsecs_ = value;
}
inline void GetPositionReply::set_positionsecs(double value) {
  _internal_set_positionsecs(value);
  // @@protoc_insertion_point(field_set:player.GetPositionReply.positionSecs)
}

// -------------------------------------------------------------------

// GetLengthRequest

// -------------------------------------------------------------------

// GetLengthReply

// double lengthSecs = 1;
inline void GetLengthReply::clear_lengthsecs() {
  _impl_.lengthsecs_ = 0;
}
inline double GetLengthReply::_internal_lengthsecs() const {
  return _impl_.lengthsecs_;
}
inline double GetLengthReply::lengthsecs() const {
  // @@protoc_insertion_point(field_get:player.GetLengthReply.lengthSecs)
  return _internal_lengthsecs();
}
inline void GetLengthReply::_internal_set_lengthsecs(double value) {
  
  _impl_.lengthsecs_ = value;
}
inline void GetLengthReply::set_lengthsecs(double value) {
  _internal_set_lengthsecs(value);
  // @@protoc_insertion_point(field_set:player.GetLengthReply.lengthSecs)
}

// -------------------------------------------------------------------

// GetSpeedRequest

// -------------------------------------------------------------------

// GetSpeedReply

// double speed = 1;
inline void GetSpeedReply::clear_speed() {
  _impl_.speed_ = 0;
}
inline double GetSpeedReply::_internal_speed() const {
  return _impl_.speed_;
}
inline double GetSpeedReply::speed() const {
  // @@protoc_insertion_point(field_get:player.GetSpeedReply.speed)
  return _internal_speed();
}
inline void GetSpeedReply::_internal_set_speed(double value) {
  
  _impl_.speed_ = value;
}
inline void GetSpeedReply::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:player.GetSpeedReply.speed)
}

// -------------------------------------------------------------------

// SetSpeedRequest

// double speed = 1;
inline void SetSpeedRequest::clear_speed() {
  _impl_.speed_ = 0;
}
inline double SetSpeedRequest::_internal_speed() const {
  return _impl_.speed_;
}
inline double SetSpeedRequest::speed() const {
  // @@protoc_insertion_point(field_get:player.SetSpeedRequest.speed)
  return _internal_speed();
}
inline void SetSpeedRequest::_internal_set_speed(double value) {
  
  _impl_.speed_ = value;
}
inline void SetSpeedRequest::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:player.SetSpeedRequest.speed)
}

// -------------------------------------------------------------------

// SetSpeedReply

// -------------------------------------------------------------------

// GetPauseRequest

// -------------------------------------------------------------------

// GetPauseReply

// bool isPaused = 1;
inline void GetPauseReply::clear_ispaused() {
  _impl_.ispaused_ = false;
}
inline bool GetPauseReply::_internal_ispaused() const {
  return _impl_.ispaused_;
}
inline bool GetPauseReply::ispaused() const {
  // @@protoc_insertion_point(field_get:player.GetPauseReply.isPaused)
  return _internal_ispaused();
}
inline void GetPauseReply::_internal_set_ispaused(bool value) {
  
  _impl_.ispaused_ = value;
}
inline void GetPauseReply::set_ispaused(bool value) {
  _internal_set_ispaused(value);
  // @@protoc_insertion_point(field_set:player.GetPauseReply.isPaused)
}

// -------------------------------------------------------------------

// SetPauseRequest

// bool isPaused = 1;
inline void SetPauseRequest::clear_ispaused() {
  _impl_.ispaused_ = false;
}
inline bool SetPauseRequest::_internal_ispaused() const {
  return _impl_.ispaused_;
}
inline bool SetPauseRequest::ispaused() const {
  // @@protoc_insertion_point(field_get:player.SetPauseRequest.isPaused)
  return _internal_ispaused();
}
inline void SetPauseRequest::_internal_set_ispaused(bool value) {
  
  _impl_.ispaused_ = value;
}
inline void SetPauseRequest::set_ispaused(bool value) {
  _internal_set_ispaused(value);
  // @@protoc_insertion_point(field_set:player.SetPauseRequest.isPaused)
}

// -------------------------------------------------------------------

// SetPauseReply

// -------------------------------------------------------------------

// SetVideoTrackRequest

// int64 videoTrackID = 1;
inline void SetVideoTrackRequest::clear_videotrackid() {
  _impl_.videotrackid_ = int64_t{0};
}
inline int64_t SetVideoTrackRequest::_internal_videotrackid() const {
  return _impl_.videotrackid_;
}
inline int64_t SetVideoTrackRequest::videotrackid() const {
  // @@protoc_insertion_point(field_get:player.SetVideoTrackRequest.videoTrackID)
  return _internal_videotrackid();
}
inline void SetVideoTrackRequest::_internal_set_videotrackid(int64_t value) {
  
  _impl_.videotrackid_ = value;
}
inline void SetVideoTrackRequest::set_videotrackid(int64_t value) {
  _internal_set_videotrackid(value);
  // @@protoc_insertion_point(field_set:player.SetVideoTrackRequest.videoTrackID)
}

// -------------------------------------------------------------------

// SetVideoTrackReply

// -------------------------------------------------------------------

// SetAudioTrackRequest

// int64 audioTrackID = 1;
inline void SetAudioTrackRequest::clear_audiotrackid() {
  _impl_.audiotrackid_ = int64_t{0};
}
inline int64_t SetAudioTrackRequest::_internal_audiotrackid() const {
  return _impl_.audiotrackid_;
}
inline int64_t SetAudioTrackRequest::audiotrackid() const {
  // @@protoc_insertion_point(field_get:player.SetAudioTrackRequest.audioTrackID)
  return _internal_audiotrackid();
}
inline void SetAudioTrackRequest::_internal_set_audiotrackid(int64_t value) {
  
  _impl_.audiotrackid_ = value;
}
inline void SetAudioTrackRequest::set_audiotrackid(int64_t value) {
  _internal_set_audiotrackid(value);
  // @@protoc_insertion_point(field_set:player.SetAudioTrackRequest.audioTrackID)
}

// -------------------------------------------------------------------

// SetAudioTrackReply

// -------------------------------------------------------------------

// SetSubtitlesTrackRequest

// int64 subtitlesTrackID = 1;
inline void SetSubtitlesTrackRequest::clear_subtitlestrackid() {
  _impl_.subtitlestrackid_ = int64_t{0};
}
inline int64_t SetSubtitlesTrackRequest::_internal_subtitlestrackid() const {
  return _impl_.subtitlestrackid_;
}
inline int64_t SetSubtitlesTrackRequest::subtitlestrackid() const {
  // @@protoc_insertion_point(field_get:player.SetSubtitlesTrackRequest.subtitlesTrackID)
  return _internal_subtitlestrackid();
}
inline void SetSubtitlesTrackRequest::_internal_set_subtitlestrackid(int64_t value) {
  
  _impl_.subtitlestrackid_ = value;
}
inline void SetSubtitlesTrackRequest::set_subtitlestrackid(int64_t value) {
  _internal_set_subtitlestrackid(value);
  // @@protoc_insertion_point(field_set:player.SetSubtitlesTrackRequest.subtitlesTrackID)
}

// -------------------------------------------------------------------

// SetSubtitlesTrackReply

// -------------------------------------------------------------------

// VideoTrack

// int64 id = 1;
inline void VideoTrack::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t VideoTrack::_internal_id() const {
  return _impl_.id_;
}
inline int64_t VideoTrack::id() const {
  // @@protoc_insertion_point(field_get:player.VideoTrack.id)
  return _internal_id();
}
inline void VideoTrack::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void VideoTrack::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:player.VideoTrack.id)
}

// bool isActive = 2;
inline void VideoTrack::clear_isactive() {
  _impl_.isactive_ = false;
}
inline bool VideoTrack::_internal_isactive() const {
  return _impl_.isactive_;
}
inline bool VideoTrack::isactive() const {
  // @@protoc_insertion_point(field_get:player.VideoTrack.isActive)
  return _internal_isactive();
}
inline void VideoTrack::_internal_set_isactive(bool value) {
  
  _impl_.isactive_ = value;
}
inline void VideoTrack::set_isactive(bool value) {
  _internal_set_isactive(value);
  // @@protoc_insertion_point(field_set:player.VideoTrack.isActive)
}

// -------------------------------------------------------------------

// SeekRequest

// int64 pos = 1;
inline void SeekRequest::clear_pos() {
  _impl_.pos_ = int64_t{0};
}
inline int64_t SeekRequest::_internal_pos() const {
  return _impl_.pos_;
}
inline int64_t SeekRequest::pos() const {
  // @@protoc_insertion_point(field_get:player.SeekRequest.pos)
  return _internal_pos();
}
inline void SeekRequest::_internal_set_pos(int64_t value) {
  
  _impl_.pos_ = value;
}
inline void SeekRequest::set_pos(int64_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:player.SeekRequest.pos)
}

// bool isRelative = 2;
inline void SeekRequest::clear_isrelative() {
  _impl_.isrelative_ = false;
}
inline bool SeekRequest::_internal_isrelative() const {
  return _impl_.isrelative_;
}
inline bool SeekRequest::isrelative() const {
  // @@protoc_insertion_point(field_get:player.SeekRequest.isRelative)
  return _internal_isrelative();
}
inline void SeekRequest::_internal_set_isrelative(bool value) {
  
  _impl_.isrelative_ = value;
}
inline void SeekRequest::set_isrelative(bool value) {
  _internal_set_isrelative(value);
  // @@protoc_insertion_point(field_set:player.SeekRequest.isRelative)
}

// bool isQuick = 3;
inline void SeekRequest::clear_isquick() {
  _impl_.isquick_ = false;
}
inline bool SeekRequest::_internal_isquick() const {
  return _impl_.isquick_;
}
inline bool SeekRequest::isquick() const {
  // @@protoc_insertion_point(field_get:player.SeekRequest.isQuick)
  return _internal_isquick();
}
inline void SeekRequest::_internal_set_isquick(bool value) {
  
  _impl_.isquick_ = value;
}
inline void SeekRequest::set_isquick(bool value) {
  _internal_set_isquick(value);
  // @@protoc_insertion_point(field_set:player.SeekRequest.isQuick)
}

// -------------------------------------------------------------------

// SeekReply

// -------------------------------------------------------------------

// GetVideoTracksRequest

// -------------------------------------------------------------------

// GetVideoTracksReply

// repeated .player.VideoTrack videoTrack = 1;
inline int GetVideoTracksReply::_internal_videotrack_size() const {
  return _impl_.videotrack_.size();
}
inline int GetVideoTracksReply::videotrack_size() const {
  return _internal_videotrack_size();
}
inline void GetVideoTracksReply::clear_videotrack() {
  _impl_.videotrack_.Clear();
}
inline ::player::VideoTrack* GetVideoTracksReply::mutable_videotrack(int index) {
  // @@protoc_insertion_point(field_mutable:player.GetVideoTracksReply.videoTrack)
  return _impl_.videotrack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::VideoTrack >*
GetVideoTracksReply::mutable_videotrack() {
  // @@protoc_insertion_point(field_mutable_list:player.GetVideoTracksReply.videoTrack)
  return &_impl_.videotrack_;
}
inline const ::player::VideoTrack& GetVideoTracksReply::_internal_videotrack(int index) const {
  return _impl_.videotrack_.Get(index);
}
inline const ::player::VideoTrack& GetVideoTracksReply::videotrack(int index) const {
  // @@protoc_insertion_point(field_get:player.GetVideoTracksReply.videoTrack)
  return _internal_videotrack(index);
}
inline ::player::VideoTrack* GetVideoTracksReply::_internal_add_videotrack() {
  return _impl_.videotrack_.Add();
}
inline ::player::VideoTrack* GetVideoTracksReply::add_videotrack() {
  ::player::VideoTrack* _add = _internal_add_videotrack();
  // @@protoc_insertion_point(field_add:player.GetVideoTracksReply.videoTrack)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::VideoTrack >&
GetVideoTracksReply::videotrack() const {
  // @@protoc_insertion_point(field_list:player.GetVideoTracksReply.videoTrack)
  return _impl_.videotrack_;
}

// -------------------------------------------------------------------

// AudioTrack

// int64 id = 1;
inline void AudioTrack::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t AudioTrack::_internal_id() const {
  return _impl_.id_;
}
inline int64_t AudioTrack::id() const {
  // @@protoc_insertion_point(field_get:player.AudioTrack.id)
  return _internal_id();
}
inline void AudioTrack::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void AudioTrack::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:player.AudioTrack.id)
}

// bool isActive = 2;
inline void AudioTrack::clear_isactive() {
  _impl_.isactive_ = false;
}
inline bool AudioTrack::_internal_isactive() const {
  return _impl_.isactive_;
}
inline bool AudioTrack::isactive() const {
  // @@protoc_insertion_point(field_get:player.AudioTrack.isActive)
  return _internal_isactive();
}
inline void AudioTrack::_internal_set_isactive(bool value) {
  
  _impl_.isactive_ = value;
}
inline void AudioTrack::set_isactive(bool value) {
  _internal_set_isactive(value);
  // @@protoc_insertion_point(field_set:player.AudioTrack.isActive)
}

// -------------------------------------------------------------------

// GetAudioTracksRequest

// -------------------------------------------------------------------

// GetAudioTracksReply

// repeated .player.AudioTrack audioTrack = 1;
inline int GetAudioTracksReply::_internal_audiotrack_size() const {
  return _impl_.audiotrack_.size();
}
inline int GetAudioTracksReply::audiotrack_size() const {
  return _internal_audiotrack_size();
}
inline void GetAudioTracksReply::clear_audiotrack() {
  _impl_.audiotrack_.Clear();
}
inline ::player::AudioTrack* GetAudioTracksReply::mutable_audiotrack(int index) {
  // @@protoc_insertion_point(field_mutable:player.GetAudioTracksReply.audioTrack)
  return _impl_.audiotrack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::AudioTrack >*
GetAudioTracksReply::mutable_audiotrack() {
  // @@protoc_insertion_point(field_mutable_list:player.GetAudioTracksReply.audioTrack)
  return &_impl_.audiotrack_;
}
inline const ::player::AudioTrack& GetAudioTracksReply::_internal_audiotrack(int index) const {
  return _impl_.audiotrack_.Get(index);
}
inline const ::player::AudioTrack& GetAudioTracksReply::audiotrack(int index) const {
  // @@protoc_insertion_point(field_get:player.GetAudioTracksReply.audioTrack)
  return _internal_audiotrack(index);
}
inline ::player::AudioTrack* GetAudioTracksReply::_internal_add_audiotrack() {
  return _impl_.audiotrack_.Add();
}
inline ::player::AudioTrack* GetAudioTracksReply::add_audiotrack() {
  ::player::AudioTrack* _add = _internal_add_audiotrack();
  // @@protoc_insertion_point(field_add:player.GetAudioTracksReply.audioTrack)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::AudioTrack >&
GetAudioTracksReply::audiotrack() const {
  // @@protoc_insertion_point(field_list:player.GetAudioTracksReply.audioTrack)
  return _impl_.audiotrack_;
}

// -------------------------------------------------------------------

// SubtitlesTrack

// int64 id = 1;
inline void SubtitlesTrack::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t SubtitlesTrack::_internal_id() const {
  return _impl_.id_;
}
inline int64_t SubtitlesTrack::id() const {
  // @@protoc_insertion_point(field_get:player.SubtitlesTrack.id)
  return _internal_id();
}
inline void SubtitlesTrack::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void SubtitlesTrack::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:player.SubtitlesTrack.id)
}

// bool isActive = 2;
inline void SubtitlesTrack::clear_isactive() {
  _impl_.isactive_ = false;
}
inline bool SubtitlesTrack::_internal_isactive() const {
  return _impl_.isactive_;
}
inline bool SubtitlesTrack::isactive() const {
  // @@protoc_insertion_point(field_get:player.SubtitlesTrack.isActive)
  return _internal_isactive();
}
inline void SubtitlesTrack::_internal_set_isactive(bool value) {
  
  _impl_.isactive_ = value;
}
inline void SubtitlesTrack::set_isactive(bool value) {
  _internal_set_isactive(value);
  // @@protoc_insertion_point(field_set:player.SubtitlesTrack.isActive)
}

// -------------------------------------------------------------------

// GetSubtitlesTracksRequest

// -------------------------------------------------------------------

// GetSubtitlesTracksReply

// repeated .player.SubtitlesTrack subtitlesTrack = 1;
inline int GetSubtitlesTracksReply::_internal_subtitlestrack_size() const {
  return _impl_.subtitlestrack_.size();
}
inline int GetSubtitlesTracksReply::subtitlestrack_size() const {
  return _internal_subtitlestrack_size();
}
inline void GetSubtitlesTracksReply::clear_subtitlestrack() {
  _impl_.subtitlestrack_.Clear();
}
inline ::player::SubtitlesTrack* GetSubtitlesTracksReply::mutable_subtitlestrack(int index) {
  // @@protoc_insertion_point(field_mutable:player.GetSubtitlesTracksReply.subtitlesTrack)
  return _impl_.subtitlestrack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::SubtitlesTrack >*
GetSubtitlesTracksReply::mutable_subtitlestrack() {
  // @@protoc_insertion_point(field_mutable_list:player.GetSubtitlesTracksReply.subtitlesTrack)
  return &_impl_.subtitlestrack_;
}
inline const ::player::SubtitlesTrack& GetSubtitlesTracksReply::_internal_subtitlestrack(int index) const {
  return _impl_.subtitlestrack_.Get(index);
}
inline const ::player::SubtitlesTrack& GetSubtitlesTracksReply::subtitlestrack(int index) const {
  // @@protoc_insertion_point(field_get:player.GetSubtitlesTracksReply.subtitlesTrack)
  return _internal_subtitlestrack(index);
}
inline ::player::SubtitlesTrack* GetSubtitlesTracksReply::_internal_add_subtitlestrack() {
  return _impl_.subtitlestrack_.Add();
}
inline ::player::SubtitlesTrack* GetSubtitlesTracksReply::add_subtitlestrack() {
  ::player::SubtitlesTrack* _add = _internal_add_subtitlestrack();
  // @@protoc_insertion_point(field_add:player.GetSubtitlesTracksReply.subtitlesTrack)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::player::SubtitlesTrack >&
GetSubtitlesTracksReply::subtitlestrack() const {
  // @@protoc_insertion_point(field_list:player.GetSubtitlesTracksReply.subtitlesTrack)
  return _impl_.subtitlestrack_;
}

// -------------------------------------------------------------------

// StopRequest

// -------------------------------------------------------------------

// StopReply

// -------------------------------------------------------------------

// CloseRequest

// -------------------------------------------------------------------

// CloseReply

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace player

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::player::LoggingLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::player::LoggingLevel>() {
  return ::player::LoggingLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_player_2eproto
