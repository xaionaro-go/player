// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: player.proto
#ifndef GRPC_player_2eproto__INCLUDED
#define GRPC_player_2eproto__INCLUDED

#include "player.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace player {

class Player final {
 public:
  static constexpr char const* service_full_name() {
    return "player.Player";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Open(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::player::OpenReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::OpenReply>> AsyncOpen(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::OpenReply>>(AsyncOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::OpenReply>> PrepareAsyncOpen(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::OpenReply>>(PrepareAsyncOpenRaw(context, request, cq));
    }
    virtual ::grpc::Status SetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::player::SetupForStreamingReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetupForStreamingReply>> AsyncSetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetupForStreamingReply>>(AsyncSetupForStreamingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetupForStreamingReply>> PrepareAsyncSetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetupForStreamingReply>>(PrepareAsyncSetupForStreamingRaw(context, request, cq));
    }
    virtual ::grpc::Status ProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::player::ProcessTitleReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::ProcessTitleReply>> AsyncProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::ProcessTitleReply>>(AsyncProcessTitleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::ProcessTitleReply>> PrepareAsyncProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::ProcessTitleReply>>(PrepareAsyncProcessTitleRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::player::GetLinkReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLinkReply>> AsyncGetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLinkReply>>(AsyncGetLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLinkReply>> PrepareAsyncGetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLinkReply>>(PrepareAsyncGetLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::player::EndChanReply>> EndChan(::grpc::ClientContext* context, const ::player::EndChanRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::player::EndChanReply>>(EndChanRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::player::EndChanReply>> AsyncEndChan(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::player::EndChanReply>>(AsyncEndChanRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::player::EndChanReply>> PrepareAsyncEndChan(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::player::EndChanReply>>(PrepareAsyncEndChanRaw(context, request, cq));
    }
    virtual ::grpc::Status IsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::player::IsEndedReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::IsEndedReply>> AsyncIsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::IsEndedReply>>(AsyncIsEndedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::IsEndedReply>> PrepareAsyncIsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::IsEndedReply>>(PrepareAsyncIsEndedRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::player::GetPositionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPositionReply>> AsyncGetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPositionReply>>(AsyncGetPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPositionReply>> PrepareAsyncGetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPositionReply>>(PrepareAsyncGetPositionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::player::GetLengthReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLengthReply>> AsyncGetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLengthReply>>(AsyncGetLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLengthReply>> PrepareAsyncGetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLengthReply>>(PrepareAsyncGetLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::player::GetSpeedReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSpeedReply>> AsyncGetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSpeedReply>>(AsyncGetSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSpeedReply>> PrepareAsyncGetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSpeedReply>>(PrepareAsyncGetSpeedRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::player::SetSpeedReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSpeedReply>> AsyncSetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSpeedReply>>(AsyncSetSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSpeedReply>> PrepareAsyncSetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSpeedReply>>(PrepareAsyncSetSpeedRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::player::GetPauseReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPauseReply>> AsyncGetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPauseReply>>(AsyncGetPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPauseReply>> PrepareAsyncGetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPauseReply>>(PrepareAsyncGetPauseRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::player::SetPauseReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetPauseReply>> AsyncSetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetPauseReply>>(AsyncSetPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetPauseReply>> PrepareAsyncSetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetPauseReply>>(PrepareAsyncSetPauseRaw(context, request, cq));
    }
    virtual ::grpc::Status Seek(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::player::SeekReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SeekReply>> AsyncSeek(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SeekReply>>(AsyncSeekRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SeekReply>> PrepareAsyncSeek(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SeekReply>>(PrepareAsyncSeekRaw(context, request, cq));
    }
    virtual ::grpc::Status GetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::player::GetVideoTracksReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetVideoTracksReply>> AsyncGetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetVideoTracksReply>>(AsyncGetVideoTracksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetVideoTracksReply>> PrepareAsyncGetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetVideoTracksReply>>(PrepareAsyncGetVideoTracksRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::player::GetAudioTracksReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetAudioTracksReply>> AsyncGetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetAudioTracksReply>>(AsyncGetAudioTracksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetAudioTracksReply>> PrepareAsyncGetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetAudioTracksReply>>(PrepareAsyncGetAudioTracksRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::player::GetSubtitlesTracksReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSubtitlesTracksReply>> AsyncGetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSubtitlesTracksReply>>(AsyncGetSubtitlesTracksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSubtitlesTracksReply>> PrepareAsyncGetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSubtitlesTracksReply>>(PrepareAsyncGetSubtitlesTracksRaw(context, request, cq));
    }
    virtual ::grpc::Status SetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::player::SetVideoTrackReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetVideoTrackReply>> AsyncSetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetVideoTrackReply>>(AsyncSetVideoTrackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetVideoTrackReply>> PrepareAsyncSetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetVideoTrackReply>>(PrepareAsyncSetVideoTrackRaw(context, request, cq));
    }
    virtual ::grpc::Status SetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::player::SetAudioTrackReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetAudioTrackReply>> AsyncSetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetAudioTrackReply>>(AsyncSetAudioTrackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetAudioTrackReply>> PrepareAsyncSetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetAudioTrackReply>>(PrepareAsyncSetAudioTrackRaw(context, request, cq));
    }
    virtual ::grpc::Status SetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::player::SetSubtitlesTrackReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSubtitlesTrackReply>> AsyncSetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSubtitlesTrackReply>>(AsyncSetSubtitlesTrackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSubtitlesTrackReply>> PrepareAsyncSetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSubtitlesTrackReply>>(PrepareAsyncSetSubtitlesTrackRaw(context, request, cq));
    }
    virtual ::grpc::Status Stop(::grpc::ClientContext* context, const ::player::StopRequest& request, ::player::StopReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::StopReply>> AsyncStop(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::StopReply>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::StopReply>> PrepareAsyncStop(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::StopReply>>(PrepareAsyncStopRaw(context, request, cq));
    }
    virtual ::grpc::Status Close(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::player::CloseReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::CloseReply>> AsyncClose(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::CloseReply>>(AsyncCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::CloseReply>> PrepareAsyncClose(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::player::CloseReply>>(PrepareAsyncCloseRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Open(::grpc::ClientContext* context, const ::player::OpenRequest* request, ::player::OpenReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Open(::grpc::ClientContext* context, const ::player::OpenRequest* request, ::player::OpenReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest* request, ::player::SetupForStreamingReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest* request, ::player::SetupForStreamingReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest* request, ::player::ProcessTitleReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest* request, ::player::ProcessTitleReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest* request, ::player::GetLinkReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest* request, ::player::GetLinkReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EndChan(::grpc::ClientContext* context, const ::player::EndChanRequest* request, ::grpc::ClientReadReactor< ::player::EndChanReply>* reactor) = 0;
      virtual void IsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest* request, ::player::IsEndedReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest* request, ::player::IsEndedReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest* request, ::player::GetPositionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest* request, ::player::GetPositionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest* request, ::player::GetLengthReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest* request, ::player::GetLengthReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest* request, ::player::GetSpeedReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest* request, ::player::GetSpeedReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest* request, ::player::SetSpeedReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest* request, ::player::SetSpeedReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest* request, ::player::GetPauseReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest* request, ::player::GetPauseReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest* request, ::player::SetPauseReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest* request, ::player::SetPauseReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Seek(::grpc::ClientContext* context, const ::player::SeekRequest* request, ::player::SeekReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Seek(::grpc::ClientContext* context, const ::player::SeekRequest* request, ::player::SeekReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest* request, ::player::GetVideoTracksReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest* request, ::player::GetVideoTracksReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest* request, ::player::GetAudioTracksReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest* request, ::player::GetAudioTracksReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest* request, ::player::GetSubtitlesTracksReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest* request, ::player::GetSubtitlesTracksReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest* request, ::player::SetVideoTrackReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest* request, ::player::SetVideoTrackReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest* request, ::player::SetAudioTrackReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest* request, ::player::SetAudioTrackReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest* request, ::player::SetSubtitlesTrackReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest* request, ::player::SetSubtitlesTrackReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::player::StopRequest* request, ::player::StopReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::player::StopRequest* request, ::player::StopReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Close(::grpc::ClientContext* context, const ::player::CloseRequest* request, ::player::CloseReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Close(::grpc::ClientContext* context, const ::player::CloseRequest* request, ::player::CloseReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::OpenReply>* AsyncOpenRaw(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::OpenReply>* PrepareAsyncOpenRaw(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetupForStreamingReply>* AsyncSetupForStreamingRaw(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetupForStreamingReply>* PrepareAsyncSetupForStreamingRaw(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::ProcessTitleReply>* AsyncProcessTitleRaw(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::ProcessTitleReply>* PrepareAsyncProcessTitleRaw(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLinkReply>* AsyncGetLinkRaw(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLinkReply>* PrepareAsyncGetLinkRaw(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::player::EndChanReply>* EndChanRaw(::grpc::ClientContext* context, const ::player::EndChanRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::player::EndChanReply>* AsyncEndChanRaw(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::player::EndChanReply>* PrepareAsyncEndChanRaw(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::IsEndedReply>* AsyncIsEndedRaw(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::IsEndedReply>* PrepareAsyncIsEndedRaw(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPositionReply>* AsyncGetPositionRaw(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPositionReply>* PrepareAsyncGetPositionRaw(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLengthReply>* AsyncGetLengthRaw(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetLengthReply>* PrepareAsyncGetLengthRaw(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSpeedReply>* AsyncGetSpeedRaw(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSpeedReply>* PrepareAsyncGetSpeedRaw(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSpeedReply>* AsyncSetSpeedRaw(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSpeedReply>* PrepareAsyncSetSpeedRaw(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPauseReply>* AsyncGetPauseRaw(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetPauseReply>* PrepareAsyncGetPauseRaw(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetPauseReply>* AsyncSetPauseRaw(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetPauseReply>* PrepareAsyncSetPauseRaw(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SeekReply>* AsyncSeekRaw(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SeekReply>* PrepareAsyncSeekRaw(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetVideoTracksReply>* AsyncGetVideoTracksRaw(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetVideoTracksReply>* PrepareAsyncGetVideoTracksRaw(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetAudioTracksReply>* AsyncGetAudioTracksRaw(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetAudioTracksReply>* PrepareAsyncGetAudioTracksRaw(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSubtitlesTracksReply>* AsyncGetSubtitlesTracksRaw(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::GetSubtitlesTracksReply>* PrepareAsyncGetSubtitlesTracksRaw(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetVideoTrackReply>* AsyncSetVideoTrackRaw(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetVideoTrackReply>* PrepareAsyncSetVideoTrackRaw(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetAudioTrackReply>* AsyncSetAudioTrackRaw(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetAudioTrackReply>* PrepareAsyncSetAudioTrackRaw(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSubtitlesTrackReply>* AsyncSetSubtitlesTrackRaw(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::SetSubtitlesTrackReply>* PrepareAsyncSetSubtitlesTrackRaw(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::StopReply>* AsyncStopRaw(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::StopReply>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::CloseReply>* AsyncCloseRaw(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::player::CloseReply>* PrepareAsyncCloseRaw(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Open(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::player::OpenReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::OpenReply>> AsyncOpen(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::OpenReply>>(AsyncOpenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::OpenReply>> PrepareAsyncOpen(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::OpenReply>>(PrepareAsyncOpenRaw(context, request, cq));
    }
    ::grpc::Status SetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::player::SetupForStreamingReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetupForStreamingReply>> AsyncSetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetupForStreamingReply>>(AsyncSetupForStreamingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetupForStreamingReply>> PrepareAsyncSetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetupForStreamingReply>>(PrepareAsyncSetupForStreamingRaw(context, request, cq));
    }
    ::grpc::Status ProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::player::ProcessTitleReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::ProcessTitleReply>> AsyncProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::ProcessTitleReply>>(AsyncProcessTitleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::ProcessTitleReply>> PrepareAsyncProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::ProcessTitleReply>>(PrepareAsyncProcessTitleRaw(context, request, cq));
    }
    ::grpc::Status GetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::player::GetLinkReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLinkReply>> AsyncGetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLinkReply>>(AsyncGetLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLinkReply>> PrepareAsyncGetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLinkReply>>(PrepareAsyncGetLinkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::player::EndChanReply>> EndChan(::grpc::ClientContext* context, const ::player::EndChanRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::player::EndChanReply>>(EndChanRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::player::EndChanReply>> AsyncEndChan(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::player::EndChanReply>>(AsyncEndChanRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::player::EndChanReply>> PrepareAsyncEndChan(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::player::EndChanReply>>(PrepareAsyncEndChanRaw(context, request, cq));
    }
    ::grpc::Status IsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::player::IsEndedReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::IsEndedReply>> AsyncIsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::IsEndedReply>>(AsyncIsEndedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::IsEndedReply>> PrepareAsyncIsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::IsEndedReply>>(PrepareAsyncIsEndedRaw(context, request, cq));
    }
    ::grpc::Status GetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::player::GetPositionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPositionReply>> AsyncGetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPositionReply>>(AsyncGetPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPositionReply>> PrepareAsyncGetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPositionReply>>(PrepareAsyncGetPositionRaw(context, request, cq));
    }
    ::grpc::Status GetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::player::GetLengthReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLengthReply>> AsyncGetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLengthReply>>(AsyncGetLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLengthReply>> PrepareAsyncGetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetLengthReply>>(PrepareAsyncGetLengthRaw(context, request, cq));
    }
    ::grpc::Status GetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::player::GetSpeedReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSpeedReply>> AsyncGetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSpeedReply>>(AsyncGetSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSpeedReply>> PrepareAsyncGetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSpeedReply>>(PrepareAsyncGetSpeedRaw(context, request, cq));
    }
    ::grpc::Status SetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::player::SetSpeedReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSpeedReply>> AsyncSetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSpeedReply>>(AsyncSetSpeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSpeedReply>> PrepareAsyncSetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSpeedReply>>(PrepareAsyncSetSpeedRaw(context, request, cq));
    }
    ::grpc::Status GetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::player::GetPauseReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPauseReply>> AsyncGetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPauseReply>>(AsyncGetPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPauseReply>> PrepareAsyncGetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetPauseReply>>(PrepareAsyncGetPauseRaw(context, request, cq));
    }
    ::grpc::Status SetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::player::SetPauseReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetPauseReply>> AsyncSetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetPauseReply>>(AsyncSetPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetPauseReply>> PrepareAsyncSetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetPauseReply>>(PrepareAsyncSetPauseRaw(context, request, cq));
    }
    ::grpc::Status Seek(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::player::SeekReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SeekReply>> AsyncSeek(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SeekReply>>(AsyncSeekRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SeekReply>> PrepareAsyncSeek(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SeekReply>>(PrepareAsyncSeekRaw(context, request, cq));
    }
    ::grpc::Status GetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::player::GetVideoTracksReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetVideoTracksReply>> AsyncGetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetVideoTracksReply>>(AsyncGetVideoTracksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetVideoTracksReply>> PrepareAsyncGetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetVideoTracksReply>>(PrepareAsyncGetVideoTracksRaw(context, request, cq));
    }
    ::grpc::Status GetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::player::GetAudioTracksReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetAudioTracksReply>> AsyncGetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetAudioTracksReply>>(AsyncGetAudioTracksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetAudioTracksReply>> PrepareAsyncGetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetAudioTracksReply>>(PrepareAsyncGetAudioTracksRaw(context, request, cq));
    }
    ::grpc::Status GetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::player::GetSubtitlesTracksReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSubtitlesTracksReply>> AsyncGetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSubtitlesTracksReply>>(AsyncGetSubtitlesTracksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSubtitlesTracksReply>> PrepareAsyncGetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::GetSubtitlesTracksReply>>(PrepareAsyncGetSubtitlesTracksRaw(context, request, cq));
    }
    ::grpc::Status SetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::player::SetVideoTrackReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetVideoTrackReply>> AsyncSetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetVideoTrackReply>>(AsyncSetVideoTrackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetVideoTrackReply>> PrepareAsyncSetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetVideoTrackReply>>(PrepareAsyncSetVideoTrackRaw(context, request, cq));
    }
    ::grpc::Status SetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::player::SetAudioTrackReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetAudioTrackReply>> AsyncSetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetAudioTrackReply>>(AsyncSetAudioTrackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetAudioTrackReply>> PrepareAsyncSetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetAudioTrackReply>>(PrepareAsyncSetAudioTrackRaw(context, request, cq));
    }
    ::grpc::Status SetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::player::SetSubtitlesTrackReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSubtitlesTrackReply>> AsyncSetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSubtitlesTrackReply>>(AsyncSetSubtitlesTrackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSubtitlesTrackReply>> PrepareAsyncSetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::SetSubtitlesTrackReply>>(PrepareAsyncSetSubtitlesTrackRaw(context, request, cq));
    }
    ::grpc::Status Stop(::grpc::ClientContext* context, const ::player::StopRequest& request, ::player::StopReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::StopReply>> AsyncStop(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::StopReply>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::StopReply>> PrepareAsyncStop(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::StopReply>>(PrepareAsyncStopRaw(context, request, cq));
    }
    ::grpc::Status Close(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::player::CloseReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::CloseReply>> AsyncClose(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::CloseReply>>(AsyncCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::CloseReply>> PrepareAsyncClose(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::player::CloseReply>>(PrepareAsyncCloseRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Open(::grpc::ClientContext* context, const ::player::OpenRequest* request, ::player::OpenReply* response, std::function<void(::grpc::Status)>) override;
      void Open(::grpc::ClientContext* context, const ::player::OpenRequest* request, ::player::OpenReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest* request, ::player::SetupForStreamingReply* response, std::function<void(::grpc::Status)>) override;
      void SetupForStreaming(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest* request, ::player::SetupForStreamingReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest* request, ::player::ProcessTitleReply* response, std::function<void(::grpc::Status)>) override;
      void ProcessTitle(::grpc::ClientContext* context, const ::player::ProcessTitleRequest* request, ::player::ProcessTitleReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest* request, ::player::GetLinkReply* response, std::function<void(::grpc::Status)>) override;
      void GetLink(::grpc::ClientContext* context, const ::player::GetLinkRequest* request, ::player::GetLinkReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EndChan(::grpc::ClientContext* context, const ::player::EndChanRequest* request, ::grpc::ClientReadReactor< ::player::EndChanReply>* reactor) override;
      void IsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest* request, ::player::IsEndedReply* response, std::function<void(::grpc::Status)>) override;
      void IsEnded(::grpc::ClientContext* context, const ::player::IsEndedRequest* request, ::player::IsEndedReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest* request, ::player::GetPositionReply* response, std::function<void(::grpc::Status)>) override;
      void GetPosition(::grpc::ClientContext* context, const ::player::GetPositionRequest* request, ::player::GetPositionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest* request, ::player::GetLengthReply* response, std::function<void(::grpc::Status)>) override;
      void GetLength(::grpc::ClientContext* context, const ::player::GetLengthRequest* request, ::player::GetLengthReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest* request, ::player::GetSpeedReply* response, std::function<void(::grpc::Status)>) override;
      void GetSpeed(::grpc::ClientContext* context, const ::player::GetSpeedRequest* request, ::player::GetSpeedReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest* request, ::player::SetSpeedReply* response, std::function<void(::grpc::Status)>) override;
      void SetSpeed(::grpc::ClientContext* context, const ::player::SetSpeedRequest* request, ::player::SetSpeedReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest* request, ::player::GetPauseReply* response, std::function<void(::grpc::Status)>) override;
      void GetPause(::grpc::ClientContext* context, const ::player::GetPauseRequest* request, ::player::GetPauseReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest* request, ::player::SetPauseReply* response, std::function<void(::grpc::Status)>) override;
      void SetPause(::grpc::ClientContext* context, const ::player::SetPauseRequest* request, ::player::SetPauseReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Seek(::grpc::ClientContext* context, const ::player::SeekRequest* request, ::player::SeekReply* response, std::function<void(::grpc::Status)>) override;
      void Seek(::grpc::ClientContext* context, const ::player::SeekRequest* request, ::player::SeekReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest* request, ::player::GetVideoTracksReply* response, std::function<void(::grpc::Status)>) override;
      void GetVideoTracks(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest* request, ::player::GetVideoTracksReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest* request, ::player::GetAudioTracksReply* response, std::function<void(::grpc::Status)>) override;
      void GetAudioTracks(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest* request, ::player::GetAudioTracksReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest* request, ::player::GetSubtitlesTracksReply* response, std::function<void(::grpc::Status)>) override;
      void GetSubtitlesTracks(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest* request, ::player::GetSubtitlesTracksReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest* request, ::player::SetVideoTrackReply* response, std::function<void(::grpc::Status)>) override;
      void SetVideoTrack(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest* request, ::player::SetVideoTrackReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest* request, ::player::SetAudioTrackReply* response, std::function<void(::grpc::Status)>) override;
      void SetAudioTrack(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest* request, ::player::SetAudioTrackReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest* request, ::player::SetSubtitlesTrackReply* response, std::function<void(::grpc::Status)>) override;
      void SetSubtitlesTrack(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest* request, ::player::SetSubtitlesTrackReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Stop(::grpc::ClientContext* context, const ::player::StopRequest* request, ::player::StopReply* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::player::StopRequest* request, ::player::StopReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Close(::grpc::ClientContext* context, const ::player::CloseRequest* request, ::player::CloseReply* response, std::function<void(::grpc::Status)>) override;
      void Close(::grpc::ClientContext* context, const ::player::CloseRequest* request, ::player::CloseReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::player::OpenReply>* AsyncOpenRaw(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::OpenReply>* PrepareAsyncOpenRaw(::grpc::ClientContext* context, const ::player::OpenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetupForStreamingReply>* AsyncSetupForStreamingRaw(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetupForStreamingReply>* PrepareAsyncSetupForStreamingRaw(::grpc::ClientContext* context, const ::player::SetupForStreamingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::ProcessTitleReply>* AsyncProcessTitleRaw(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::ProcessTitleReply>* PrepareAsyncProcessTitleRaw(::grpc::ClientContext* context, const ::player::ProcessTitleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetLinkReply>* AsyncGetLinkRaw(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetLinkReply>* PrepareAsyncGetLinkRaw(::grpc::ClientContext* context, const ::player::GetLinkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::player::EndChanReply>* EndChanRaw(::grpc::ClientContext* context, const ::player::EndChanRequest& request) override;
    ::grpc::ClientAsyncReader< ::player::EndChanReply>* AsyncEndChanRaw(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::player::EndChanReply>* PrepareAsyncEndChanRaw(::grpc::ClientContext* context, const ::player::EndChanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::IsEndedReply>* AsyncIsEndedRaw(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::IsEndedReply>* PrepareAsyncIsEndedRaw(::grpc::ClientContext* context, const ::player::IsEndedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetPositionReply>* AsyncGetPositionRaw(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetPositionReply>* PrepareAsyncGetPositionRaw(::grpc::ClientContext* context, const ::player::GetPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetLengthReply>* AsyncGetLengthRaw(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetLengthReply>* PrepareAsyncGetLengthRaw(::grpc::ClientContext* context, const ::player::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetSpeedReply>* AsyncGetSpeedRaw(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetSpeedReply>* PrepareAsyncGetSpeedRaw(::grpc::ClientContext* context, const ::player::GetSpeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetSpeedReply>* AsyncSetSpeedRaw(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetSpeedReply>* PrepareAsyncSetSpeedRaw(::grpc::ClientContext* context, const ::player::SetSpeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetPauseReply>* AsyncGetPauseRaw(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetPauseReply>* PrepareAsyncGetPauseRaw(::grpc::ClientContext* context, const ::player::GetPauseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetPauseReply>* AsyncSetPauseRaw(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetPauseReply>* PrepareAsyncSetPauseRaw(::grpc::ClientContext* context, const ::player::SetPauseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SeekReply>* AsyncSeekRaw(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SeekReply>* PrepareAsyncSeekRaw(::grpc::ClientContext* context, const ::player::SeekRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetVideoTracksReply>* AsyncGetVideoTracksRaw(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetVideoTracksReply>* PrepareAsyncGetVideoTracksRaw(::grpc::ClientContext* context, const ::player::GetVideoTracksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetAudioTracksReply>* AsyncGetAudioTracksRaw(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetAudioTracksReply>* PrepareAsyncGetAudioTracksRaw(::grpc::ClientContext* context, const ::player::GetAudioTracksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetSubtitlesTracksReply>* AsyncGetSubtitlesTracksRaw(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::GetSubtitlesTracksReply>* PrepareAsyncGetSubtitlesTracksRaw(::grpc::ClientContext* context, const ::player::GetSubtitlesTracksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetVideoTrackReply>* AsyncSetVideoTrackRaw(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetVideoTrackReply>* PrepareAsyncSetVideoTrackRaw(::grpc::ClientContext* context, const ::player::SetVideoTrackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetAudioTrackReply>* AsyncSetAudioTrackRaw(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetAudioTrackReply>* PrepareAsyncSetAudioTrackRaw(::grpc::ClientContext* context, const ::player::SetAudioTrackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetSubtitlesTrackReply>* AsyncSetSubtitlesTrackRaw(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::SetSubtitlesTrackReply>* PrepareAsyncSetSubtitlesTrackRaw(::grpc::ClientContext* context, const ::player::SetSubtitlesTrackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::StopReply>* AsyncStopRaw(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::StopReply>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::player::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::CloseReply>* AsyncCloseRaw(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::player::CloseReply>* PrepareAsyncCloseRaw(::grpc::ClientContext* context, const ::player::CloseRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Open_;
    const ::grpc::internal::RpcMethod rpcmethod_SetupForStreaming_;
    const ::grpc::internal::RpcMethod rpcmethod_ProcessTitle_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLink_;
    const ::grpc::internal::RpcMethod rpcmethod_EndChan_;
    const ::grpc::internal::RpcMethod rpcmethod_IsEnded_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPosition_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLength_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSpeed_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSpeed_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPause_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPause_;
    const ::grpc::internal::RpcMethod rpcmethod_Seek_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVideoTracks_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAudioTracks_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSubtitlesTracks_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVideoTrack_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAudioTrack_;
    const ::grpc::internal::RpcMethod rpcmethod_SetSubtitlesTrack_;
    const ::grpc::internal::RpcMethod rpcmethod_Stop_;
    const ::grpc::internal::RpcMethod rpcmethod_Close_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Open(::grpc::ServerContext* context, const ::player::OpenRequest* request, ::player::OpenReply* response);
    virtual ::grpc::Status SetupForStreaming(::grpc::ServerContext* context, const ::player::SetupForStreamingRequest* request, ::player::SetupForStreamingReply* response);
    virtual ::grpc::Status ProcessTitle(::grpc::ServerContext* context, const ::player::ProcessTitleRequest* request, ::player::ProcessTitleReply* response);
    virtual ::grpc::Status GetLink(::grpc::ServerContext* context, const ::player::GetLinkRequest* request, ::player::GetLinkReply* response);
    virtual ::grpc::Status EndChan(::grpc::ServerContext* context, const ::player::EndChanRequest* request, ::grpc::ServerWriter< ::player::EndChanReply>* writer);
    virtual ::grpc::Status IsEnded(::grpc::ServerContext* context, const ::player::IsEndedRequest* request, ::player::IsEndedReply* response);
    virtual ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::player::GetPositionRequest* request, ::player::GetPositionReply* response);
    virtual ::grpc::Status GetLength(::grpc::ServerContext* context, const ::player::GetLengthRequest* request, ::player::GetLengthReply* response);
    virtual ::grpc::Status GetSpeed(::grpc::ServerContext* context, const ::player::GetSpeedRequest* request, ::player::GetSpeedReply* response);
    virtual ::grpc::Status SetSpeed(::grpc::ServerContext* context, const ::player::SetSpeedRequest* request, ::player::SetSpeedReply* response);
    virtual ::grpc::Status GetPause(::grpc::ServerContext* context, const ::player::GetPauseRequest* request, ::player::GetPauseReply* response);
    virtual ::grpc::Status SetPause(::grpc::ServerContext* context, const ::player::SetPauseRequest* request, ::player::SetPauseReply* response);
    virtual ::grpc::Status Seek(::grpc::ServerContext* context, const ::player::SeekRequest* request, ::player::SeekReply* response);
    virtual ::grpc::Status GetVideoTracks(::grpc::ServerContext* context, const ::player::GetVideoTracksRequest* request, ::player::GetVideoTracksReply* response);
    virtual ::grpc::Status GetAudioTracks(::grpc::ServerContext* context, const ::player::GetAudioTracksRequest* request, ::player::GetAudioTracksReply* response);
    virtual ::grpc::Status GetSubtitlesTracks(::grpc::ServerContext* context, const ::player::GetSubtitlesTracksRequest* request, ::player::GetSubtitlesTracksReply* response);
    virtual ::grpc::Status SetVideoTrack(::grpc::ServerContext* context, const ::player::SetVideoTrackRequest* request, ::player::SetVideoTrackReply* response);
    virtual ::grpc::Status SetAudioTrack(::grpc::ServerContext* context, const ::player::SetAudioTrackRequest* request, ::player::SetAudioTrackReply* response);
    virtual ::grpc::Status SetSubtitlesTrack(::grpc::ServerContext* context, const ::player::SetSubtitlesTrackRequest* request, ::player::SetSubtitlesTrackReply* response);
    virtual ::grpc::Status Stop(::grpc::ServerContext* context, const ::player::StopRequest* request, ::player::StopReply* response);
    virtual ::grpc::Status Close(::grpc::ServerContext* context, const ::player::CloseRequest* request, ::player::CloseReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Open() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::player::OpenRequest* /*request*/, ::player::OpenReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpen(::grpc::ServerContext* context, ::player::OpenRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::OpenReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetupForStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetupForStreaming() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SetupForStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetupForStreaming(::grpc::ServerContext* /*context*/, const ::player::SetupForStreamingRequest* /*request*/, ::player::SetupForStreamingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetupForStreaming(::grpc::ServerContext* context, ::player::SetupForStreamingRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::SetupForStreamingReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProcessTitle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProcessTitle() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ProcessTitle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTitle(::grpc::ServerContext* /*context*/, const ::player::ProcessTitleRequest* /*request*/, ::player::ProcessTitleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessTitle(::grpc::ServerContext* context, ::player::ProcessTitleRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::ProcessTitleReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLink() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::player::GetLinkRequest* /*request*/, ::player::GetLinkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLink(::grpc::ServerContext* context, ::player::GetLinkRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetLinkReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EndChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EndChan() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_EndChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndChan(::grpc::ServerContext* /*context*/, const ::player::EndChanRequest* /*request*/, ::grpc::ServerWriter< ::player::EndChanReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEndChan(::grpc::ServerContext* context, ::player::EndChanRequest* request, ::grpc::ServerAsyncWriter< ::player::EndChanReply>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsEnded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsEnded() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_IsEnded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsEnded(::grpc::ServerContext* /*context*/, const ::player::IsEndedRequest* /*request*/, ::player::IsEndedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsEnded(::grpc::ServerContext* context, ::player::IsEndedRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::IsEndedReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPosition() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* /*context*/, const ::player::GetPositionRequest* /*request*/, ::player::GetPositionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosition(::grpc::ServerContext* context, ::player::GetPositionRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetPositionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLength() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLength(::grpc::ServerContext* /*context*/, const ::player::GetLengthRequest* /*request*/, ::player::GetLengthReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLength(::grpc::ServerContext* context, ::player::GetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetLengthReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSpeed() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpeed(::grpc::ServerContext* /*context*/, const ::player::GetSpeedRequest* /*request*/, ::player::GetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpeed(::grpc::ServerContext* context, ::player::GetSpeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetSpeedReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSpeed() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_SetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeed(::grpc::ServerContext* /*context*/, const ::player::SetSpeedRequest* /*request*/, ::player::SetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSpeed(::grpc::ServerContext* context, ::player::SetSpeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::SetSpeedReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPause() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPause(::grpc::ServerContext* /*context*/, const ::player::GetPauseRequest* /*request*/, ::player::GetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPause(::grpc::ServerContext* context, ::player::GetPauseRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetPauseReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPause() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_SetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPause(::grpc::ServerContext* /*context*/, const ::player::SetPauseRequest* /*request*/, ::player::SetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPause(::grpc::ServerContext* context, ::player::SetPauseRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::SetPauseReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Seek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Seek() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_Seek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Seek(::grpc::ServerContext* /*context*/, const ::player::SeekRequest* /*request*/, ::player::SeekReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSeek(::grpc::ServerContext* context, ::player::SeekRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::SeekReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVideoTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVideoTracks() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetVideoTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoTracks(::grpc::ServerContext* /*context*/, const ::player::GetVideoTracksRequest* /*request*/, ::player::GetVideoTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVideoTracks(::grpc::ServerContext* context, ::player::GetVideoTracksRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetVideoTracksReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAudioTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAudioTracks() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetAudioTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAudioTracks(::grpc::ServerContext* /*context*/, const ::player::GetAudioTracksRequest* /*request*/, ::player::GetAudioTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAudioTracks(::grpc::ServerContext* context, ::player::GetAudioTracksRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetAudioTracksReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSubtitlesTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSubtitlesTracks() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetSubtitlesTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubtitlesTracks(::grpc::ServerContext* /*context*/, const ::player::GetSubtitlesTracksRequest* /*request*/, ::player::GetSubtitlesTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSubtitlesTracks(::grpc::ServerContext* context, ::player::GetSubtitlesTracksRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::GetSubtitlesTracksReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVideoTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVideoTrack() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_SetVideoTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVideoTrack(::grpc::ServerContext* /*context*/, const ::player::SetVideoTrackRequest* /*request*/, ::player::SetVideoTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVideoTrack(::grpc::ServerContext* context, ::player::SetVideoTrackRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::SetVideoTrackReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAudioTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAudioTrack() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_SetAudioTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAudioTrack(::grpc::ServerContext* /*context*/, const ::player::SetAudioTrackRequest* /*request*/, ::player::SetAudioTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAudioTrack(::grpc::ServerContext* context, ::player::SetAudioTrackRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::SetAudioTrackReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetSubtitlesTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetSubtitlesTrack() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_SetSubtitlesTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSubtitlesTrack(::grpc::ServerContext* /*context*/, const ::player::SetSubtitlesTrackRequest* /*request*/, ::player::SetSubtitlesTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSubtitlesTrack(::grpc::ServerContext* context, ::player::SetSubtitlesTrackRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::SetSubtitlesTrackReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Stop() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::player::StopRequest* /*request*/, ::player::StopReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::player::StopRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::StopReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Close() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::player::CloseRequest* /*request*/, ::player::CloseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClose(::grpc::ServerContext* context, ::player::CloseRequest* request, ::grpc::ServerAsyncResponseWriter< ::player::CloseReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Open<WithAsyncMethod_SetupForStreaming<WithAsyncMethod_ProcessTitle<WithAsyncMethod_GetLink<WithAsyncMethod_EndChan<WithAsyncMethod_IsEnded<WithAsyncMethod_GetPosition<WithAsyncMethod_GetLength<WithAsyncMethod_GetSpeed<WithAsyncMethod_SetSpeed<WithAsyncMethod_GetPause<WithAsyncMethod_SetPause<WithAsyncMethod_Seek<WithAsyncMethod_GetVideoTracks<WithAsyncMethod_GetAudioTracks<WithAsyncMethod_GetSubtitlesTracks<WithAsyncMethod_SetVideoTrack<WithAsyncMethod_SetAudioTrack<WithAsyncMethod_SetSubtitlesTrack<WithAsyncMethod_Stop<WithAsyncMethod_Close<Service > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Open() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::player::OpenRequest, ::player::OpenReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::OpenRequest* request, ::player::OpenReply* response) { return this->Open(context, request, response); }));}
    void SetMessageAllocatorFor_Open(
        ::grpc::MessageAllocator< ::player::OpenRequest, ::player::OpenReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::OpenRequest, ::player::OpenReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::player::OpenRequest* /*request*/, ::player::OpenReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Open(
      ::grpc::CallbackServerContext* /*context*/, const ::player::OpenRequest* /*request*/, ::player::OpenReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetupForStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetupForStreaming() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::player::SetupForStreamingRequest, ::player::SetupForStreamingReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::SetupForStreamingRequest* request, ::player::SetupForStreamingReply* response) { return this->SetupForStreaming(context, request, response); }));}
    void SetMessageAllocatorFor_SetupForStreaming(
        ::grpc::MessageAllocator< ::player::SetupForStreamingRequest, ::player::SetupForStreamingReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::SetupForStreamingRequest, ::player::SetupForStreamingReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetupForStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetupForStreaming(::grpc::ServerContext* /*context*/, const ::player::SetupForStreamingRequest* /*request*/, ::player::SetupForStreamingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetupForStreaming(
      ::grpc::CallbackServerContext* /*context*/, const ::player::SetupForStreamingRequest* /*request*/, ::player::SetupForStreamingReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProcessTitle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ProcessTitle() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::player::ProcessTitleRequest, ::player::ProcessTitleReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::ProcessTitleRequest* request, ::player::ProcessTitleReply* response) { return this->ProcessTitle(context, request, response); }));}
    void SetMessageAllocatorFor_ProcessTitle(
        ::grpc::MessageAllocator< ::player::ProcessTitleRequest, ::player::ProcessTitleReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::ProcessTitleRequest, ::player::ProcessTitleReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProcessTitle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTitle(::grpc::ServerContext* /*context*/, const ::player::ProcessTitleRequest* /*request*/, ::player::ProcessTitleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProcessTitle(
      ::grpc::CallbackServerContext* /*context*/, const ::player::ProcessTitleRequest* /*request*/, ::player::ProcessTitleReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLink() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetLinkRequest, ::player::GetLinkReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetLinkRequest* request, ::player::GetLinkReply* response) { return this->GetLink(context, request, response); }));}
    void SetMessageAllocatorFor_GetLink(
        ::grpc::MessageAllocator< ::player::GetLinkRequest, ::player::GetLinkReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetLinkRequest, ::player::GetLinkReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::player::GetLinkRequest* /*request*/, ::player::GetLinkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLink(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetLinkRequest* /*request*/, ::player::GetLinkReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EndChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EndChan() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::player::EndChanRequest, ::player::EndChanReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::EndChanRequest* request) { return this->EndChan(context, request); }));
    }
    ~WithCallbackMethod_EndChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndChan(::grpc::ServerContext* /*context*/, const ::player::EndChanRequest* /*request*/, ::grpc::ServerWriter< ::player::EndChanReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::player::EndChanReply>* EndChan(
      ::grpc::CallbackServerContext* /*context*/, const ::player::EndChanRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_IsEnded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_IsEnded() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::player::IsEndedRequest, ::player::IsEndedReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::IsEndedRequest* request, ::player::IsEndedReply* response) { return this->IsEnded(context, request, response); }));}
    void SetMessageAllocatorFor_IsEnded(
        ::grpc::MessageAllocator< ::player::IsEndedRequest, ::player::IsEndedReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::IsEndedRequest, ::player::IsEndedReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_IsEnded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsEnded(::grpc::ServerContext* /*context*/, const ::player::IsEndedRequest* /*request*/, ::player::IsEndedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsEnded(
      ::grpc::CallbackServerContext* /*context*/, const ::player::IsEndedRequest* /*request*/, ::player::IsEndedReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPosition() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetPositionRequest, ::player::GetPositionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetPositionRequest* request, ::player::GetPositionReply* response) { return this->GetPosition(context, request, response); }));}
    void SetMessageAllocatorFor_GetPosition(
        ::grpc::MessageAllocator< ::player::GetPositionRequest, ::player::GetPositionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetPositionRequest, ::player::GetPositionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* /*context*/, const ::player::GetPositionRequest* /*request*/, ::player::GetPositionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetPositionRequest* /*request*/, ::player::GetPositionReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLength() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetLengthRequest, ::player::GetLengthReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetLengthRequest* request, ::player::GetLengthReply* response) { return this->GetLength(context, request, response); }));}
    void SetMessageAllocatorFor_GetLength(
        ::grpc::MessageAllocator< ::player::GetLengthRequest, ::player::GetLengthReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetLengthRequest, ::player::GetLengthReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLength(::grpc::ServerContext* /*context*/, const ::player::GetLengthRequest* /*request*/, ::player::GetLengthReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLength(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetLengthRequest* /*request*/, ::player::GetLengthReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSpeed() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetSpeedRequest, ::player::GetSpeedReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetSpeedRequest* request, ::player::GetSpeedReply* response) { return this->GetSpeed(context, request, response); }));}
    void SetMessageAllocatorFor_GetSpeed(
        ::grpc::MessageAllocator< ::player::GetSpeedRequest, ::player::GetSpeedReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetSpeedRequest, ::player::GetSpeedReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpeed(::grpc::ServerContext* /*context*/, const ::player::GetSpeedRequest* /*request*/, ::player::GetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetSpeedRequest* /*request*/, ::player::GetSpeedReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSpeed() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::player::SetSpeedRequest, ::player::SetSpeedReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::SetSpeedRequest* request, ::player::SetSpeedReply* response) { return this->SetSpeed(context, request, response); }));}
    void SetMessageAllocatorFor_SetSpeed(
        ::grpc::MessageAllocator< ::player::SetSpeedRequest, ::player::SetSpeedReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::SetSpeedRequest, ::player::SetSpeedReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeed(::grpc::ServerContext* /*context*/, const ::player::SetSpeedRequest* /*request*/, ::player::SetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::player::SetSpeedRequest* /*request*/, ::player::SetSpeedReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPause() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetPauseRequest, ::player::GetPauseReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetPauseRequest* request, ::player::GetPauseReply* response) { return this->GetPause(context, request, response); }));}
    void SetMessageAllocatorFor_GetPause(
        ::grpc::MessageAllocator< ::player::GetPauseRequest, ::player::GetPauseReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetPauseRequest, ::player::GetPauseReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPause(::grpc::ServerContext* /*context*/, const ::player::GetPauseRequest* /*request*/, ::player::GetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPause(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetPauseRequest* /*request*/, ::player::GetPauseReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetPause() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::player::SetPauseRequest, ::player::SetPauseReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::SetPauseRequest* request, ::player::SetPauseReply* response) { return this->SetPause(context, request, response); }));}
    void SetMessageAllocatorFor_SetPause(
        ::grpc::MessageAllocator< ::player::SetPauseRequest, ::player::SetPauseReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::SetPauseRequest, ::player::SetPauseReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPause(::grpc::ServerContext* /*context*/, const ::player::SetPauseRequest* /*request*/, ::player::SetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPause(
      ::grpc::CallbackServerContext* /*context*/, const ::player::SetPauseRequest* /*request*/, ::player::SetPauseReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Seek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Seek() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::player::SeekRequest, ::player::SeekReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::SeekRequest* request, ::player::SeekReply* response) { return this->Seek(context, request, response); }));}
    void SetMessageAllocatorFor_Seek(
        ::grpc::MessageAllocator< ::player::SeekRequest, ::player::SeekReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::SeekRequest, ::player::SeekReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Seek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Seek(::grpc::ServerContext* /*context*/, const ::player::SeekRequest* /*request*/, ::player::SeekReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Seek(
      ::grpc::CallbackServerContext* /*context*/, const ::player::SeekRequest* /*request*/, ::player::SeekReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVideoTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVideoTracks() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetVideoTracksRequest, ::player::GetVideoTracksReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetVideoTracksRequest* request, ::player::GetVideoTracksReply* response) { return this->GetVideoTracks(context, request, response); }));}
    void SetMessageAllocatorFor_GetVideoTracks(
        ::grpc::MessageAllocator< ::player::GetVideoTracksRequest, ::player::GetVideoTracksReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetVideoTracksRequest, ::player::GetVideoTracksReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVideoTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoTracks(::grpc::ServerContext* /*context*/, const ::player::GetVideoTracksRequest* /*request*/, ::player::GetVideoTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVideoTracks(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetVideoTracksRequest* /*request*/, ::player::GetVideoTracksReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAudioTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAudioTracks() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetAudioTracksRequest, ::player::GetAudioTracksReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetAudioTracksRequest* request, ::player::GetAudioTracksReply* response) { return this->GetAudioTracks(context, request, response); }));}
    void SetMessageAllocatorFor_GetAudioTracks(
        ::grpc::MessageAllocator< ::player::GetAudioTracksRequest, ::player::GetAudioTracksReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetAudioTracksRequest, ::player::GetAudioTracksReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAudioTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAudioTracks(::grpc::ServerContext* /*context*/, const ::player::GetAudioTracksRequest* /*request*/, ::player::GetAudioTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAudioTracks(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetAudioTracksRequest* /*request*/, ::player::GetAudioTracksReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSubtitlesTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSubtitlesTracks() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::player::GetSubtitlesTracksRequest, ::player::GetSubtitlesTracksReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::GetSubtitlesTracksRequest* request, ::player::GetSubtitlesTracksReply* response) { return this->GetSubtitlesTracks(context, request, response); }));}
    void SetMessageAllocatorFor_GetSubtitlesTracks(
        ::grpc::MessageAllocator< ::player::GetSubtitlesTracksRequest, ::player::GetSubtitlesTracksReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::GetSubtitlesTracksRequest, ::player::GetSubtitlesTracksReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSubtitlesTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubtitlesTracks(::grpc::ServerContext* /*context*/, const ::player::GetSubtitlesTracksRequest* /*request*/, ::player::GetSubtitlesTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSubtitlesTracks(
      ::grpc::CallbackServerContext* /*context*/, const ::player::GetSubtitlesTracksRequest* /*request*/, ::player::GetSubtitlesTracksReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetVideoTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetVideoTrack() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::player::SetVideoTrackRequest, ::player::SetVideoTrackReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::SetVideoTrackRequest* request, ::player::SetVideoTrackReply* response) { return this->SetVideoTrack(context, request, response); }));}
    void SetMessageAllocatorFor_SetVideoTrack(
        ::grpc::MessageAllocator< ::player::SetVideoTrackRequest, ::player::SetVideoTrackReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::SetVideoTrackRequest, ::player::SetVideoTrackReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetVideoTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVideoTrack(::grpc::ServerContext* /*context*/, const ::player::SetVideoTrackRequest* /*request*/, ::player::SetVideoTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVideoTrack(
      ::grpc::CallbackServerContext* /*context*/, const ::player::SetVideoTrackRequest* /*request*/, ::player::SetVideoTrackReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAudioTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAudioTrack() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::player::SetAudioTrackRequest, ::player::SetAudioTrackReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::SetAudioTrackRequest* request, ::player::SetAudioTrackReply* response) { return this->SetAudioTrack(context, request, response); }));}
    void SetMessageAllocatorFor_SetAudioTrack(
        ::grpc::MessageAllocator< ::player::SetAudioTrackRequest, ::player::SetAudioTrackReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::SetAudioTrackRequest, ::player::SetAudioTrackReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAudioTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAudioTrack(::grpc::ServerContext* /*context*/, const ::player::SetAudioTrackRequest* /*request*/, ::player::SetAudioTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAudioTrack(
      ::grpc::CallbackServerContext* /*context*/, const ::player::SetAudioTrackRequest* /*request*/, ::player::SetAudioTrackReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetSubtitlesTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetSubtitlesTrack() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::player::SetSubtitlesTrackRequest, ::player::SetSubtitlesTrackReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::SetSubtitlesTrackRequest* request, ::player::SetSubtitlesTrackReply* response) { return this->SetSubtitlesTrack(context, request, response); }));}
    void SetMessageAllocatorFor_SetSubtitlesTrack(
        ::grpc::MessageAllocator< ::player::SetSubtitlesTrackRequest, ::player::SetSubtitlesTrackReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::SetSubtitlesTrackRequest, ::player::SetSubtitlesTrackReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetSubtitlesTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSubtitlesTrack(::grpc::ServerContext* /*context*/, const ::player::SetSubtitlesTrackRequest* /*request*/, ::player::SetSubtitlesTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSubtitlesTrack(
      ::grpc::CallbackServerContext* /*context*/, const ::player::SetSubtitlesTrackRequest* /*request*/, ::player::SetSubtitlesTrackReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Stop() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::player::StopRequest, ::player::StopReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::StopRequest* request, ::player::StopReply* response) { return this->Stop(context, request, response); }));}
    void SetMessageAllocatorFor_Stop(
        ::grpc::MessageAllocator< ::player::StopRequest, ::player::StopReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::StopRequest, ::player::StopReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::player::StopRequest* /*request*/, ::player::StopReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::player::StopRequest* /*request*/, ::player::StopReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Close() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::player::CloseRequest, ::player::CloseReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::player::CloseRequest* request, ::player::CloseReply* response) { return this->Close(context, request, response); }));}
    void SetMessageAllocatorFor_Close(
        ::grpc::MessageAllocator< ::player::CloseRequest, ::player::CloseReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::player::CloseRequest, ::player::CloseReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::player::CloseRequest* /*request*/, ::player::CloseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Close(
      ::grpc::CallbackServerContext* /*context*/, const ::player::CloseRequest* /*request*/, ::player::CloseReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Open<WithCallbackMethod_SetupForStreaming<WithCallbackMethod_ProcessTitle<WithCallbackMethod_GetLink<WithCallbackMethod_EndChan<WithCallbackMethod_IsEnded<WithCallbackMethod_GetPosition<WithCallbackMethod_GetLength<WithCallbackMethod_GetSpeed<WithCallbackMethod_SetSpeed<WithCallbackMethod_GetPause<WithCallbackMethod_SetPause<WithCallbackMethod_Seek<WithCallbackMethod_GetVideoTracks<WithCallbackMethod_GetAudioTracks<WithCallbackMethod_GetSubtitlesTracks<WithCallbackMethod_SetVideoTrack<WithCallbackMethod_SetAudioTrack<WithCallbackMethod_SetSubtitlesTrack<WithCallbackMethod_Stop<WithCallbackMethod_Close<Service > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Open() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::player::OpenRequest* /*request*/, ::player::OpenReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetupForStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetupForStreaming() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SetupForStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetupForStreaming(::grpc::ServerContext* /*context*/, const ::player::SetupForStreamingRequest* /*request*/, ::player::SetupForStreamingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProcessTitle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProcessTitle() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ProcessTitle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTitle(::grpc::ServerContext* /*context*/, const ::player::ProcessTitleRequest* /*request*/, ::player::ProcessTitleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLink() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::player::GetLinkRequest* /*request*/, ::player::GetLinkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EndChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EndChan() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_EndChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndChan(::grpc::ServerContext* /*context*/, const ::player::EndChanRequest* /*request*/, ::grpc::ServerWriter< ::player::EndChanReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsEnded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsEnded() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_IsEnded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsEnded(::grpc::ServerContext* /*context*/, const ::player::IsEndedRequest* /*request*/, ::player::IsEndedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPosition() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* /*context*/, const ::player::GetPositionRequest* /*request*/, ::player::GetPositionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLength() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLength(::grpc::ServerContext* /*context*/, const ::player::GetLengthRequest* /*request*/, ::player::GetLengthReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSpeed() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpeed(::grpc::ServerContext* /*context*/, const ::player::GetSpeedRequest* /*request*/, ::player::GetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSpeed() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_SetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeed(::grpc::ServerContext* /*context*/, const ::player::SetSpeedRequest* /*request*/, ::player::SetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPause() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPause(::grpc::ServerContext* /*context*/, const ::player::GetPauseRequest* /*request*/, ::player::GetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPause() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_SetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPause(::grpc::ServerContext* /*context*/, const ::player::SetPauseRequest* /*request*/, ::player::SetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Seek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Seek() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_Seek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Seek(::grpc::ServerContext* /*context*/, const ::player::SeekRequest* /*request*/, ::player::SeekReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVideoTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVideoTracks() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetVideoTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoTracks(::grpc::ServerContext* /*context*/, const ::player::GetVideoTracksRequest* /*request*/, ::player::GetVideoTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAudioTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAudioTracks() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetAudioTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAudioTracks(::grpc::ServerContext* /*context*/, const ::player::GetAudioTracksRequest* /*request*/, ::player::GetAudioTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSubtitlesTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSubtitlesTracks() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetSubtitlesTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubtitlesTracks(::grpc::ServerContext* /*context*/, const ::player::GetSubtitlesTracksRequest* /*request*/, ::player::GetSubtitlesTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVideoTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVideoTrack() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_SetVideoTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVideoTrack(::grpc::ServerContext* /*context*/, const ::player::SetVideoTrackRequest* /*request*/, ::player::SetVideoTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAudioTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAudioTrack() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_SetAudioTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAudioTrack(::grpc::ServerContext* /*context*/, const ::player::SetAudioTrackRequest* /*request*/, ::player::SetAudioTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetSubtitlesTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetSubtitlesTrack() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_SetSubtitlesTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSubtitlesTrack(::grpc::ServerContext* /*context*/, const ::player::SetSubtitlesTrackRequest* /*request*/, ::player::SetSubtitlesTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Stop() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::player::StopRequest* /*request*/, ::player::StopReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Close() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::player::CloseRequest* /*request*/, ::player::CloseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Open() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::player::OpenRequest* /*request*/, ::player::OpenReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOpen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetupForStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetupForStreaming() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SetupForStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetupForStreaming(::grpc::ServerContext* /*context*/, const ::player::SetupForStreamingRequest* /*request*/, ::player::SetupForStreamingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetupForStreaming(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProcessTitle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProcessTitle() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ProcessTitle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTitle(::grpc::ServerContext* /*context*/, const ::player::ProcessTitleRequest* /*request*/, ::player::ProcessTitleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessTitle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLink() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::player::GetLinkRequest* /*request*/, ::player::GetLinkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLink(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EndChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EndChan() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_EndChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndChan(::grpc::ServerContext* /*context*/, const ::player::EndChanRequest* /*request*/, ::grpc::ServerWriter< ::player::EndChanReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEndChan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsEnded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsEnded() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_IsEnded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsEnded(::grpc::ServerContext* /*context*/, const ::player::IsEndedRequest* /*request*/, ::player::IsEndedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsEnded(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPosition() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* /*context*/, const ::player::GetPositionRequest* /*request*/, ::player::GetPositionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLength() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLength(::grpc::ServerContext* /*context*/, const ::player::GetLengthRequest* /*request*/, ::player::GetLengthReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSpeed() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpeed(::grpc::ServerContext* /*context*/, const ::player::GetSpeedRequest* /*request*/, ::player::GetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSpeed() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_SetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeed(::grpc::ServerContext* /*context*/, const ::player::SetSpeedRequest* /*request*/, ::player::SetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSpeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPause() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPause(::grpc::ServerContext* /*context*/, const ::player::GetPauseRequest* /*request*/, ::player::GetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPause(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPause() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_SetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPause(::grpc::ServerContext* /*context*/, const ::player::SetPauseRequest* /*request*/, ::player::SetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPause(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Seek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Seek() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_Seek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Seek(::grpc::ServerContext* /*context*/, const ::player::SeekRequest* /*request*/, ::player::SeekReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSeek(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVideoTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVideoTracks() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetVideoTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoTracks(::grpc::ServerContext* /*context*/, const ::player::GetVideoTracksRequest* /*request*/, ::player::GetVideoTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVideoTracks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAudioTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAudioTracks() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetAudioTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAudioTracks(::grpc::ServerContext* /*context*/, const ::player::GetAudioTracksRequest* /*request*/, ::player::GetAudioTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAudioTracks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSubtitlesTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSubtitlesTracks() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetSubtitlesTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubtitlesTracks(::grpc::ServerContext* /*context*/, const ::player::GetSubtitlesTracksRequest* /*request*/, ::player::GetSubtitlesTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSubtitlesTracks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVideoTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVideoTrack() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_SetVideoTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVideoTrack(::grpc::ServerContext* /*context*/, const ::player::SetVideoTrackRequest* /*request*/, ::player::SetVideoTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVideoTrack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAudioTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAudioTrack() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_SetAudioTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAudioTrack(::grpc::ServerContext* /*context*/, const ::player::SetAudioTrackRequest* /*request*/, ::player::SetAudioTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAudioTrack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetSubtitlesTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetSubtitlesTrack() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_SetSubtitlesTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSubtitlesTrack(::grpc::ServerContext* /*context*/, const ::player::SetSubtitlesTrackRequest* /*request*/, ::player::SetSubtitlesTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetSubtitlesTrack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Stop() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::player::StopRequest* /*request*/, ::player::StopReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Close() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::player::CloseRequest* /*request*/, ::player::CloseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Open() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Open(context, request, response); }));
    }
    ~WithRawCallbackMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::player::OpenRequest* /*request*/, ::player::OpenReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Open(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetupForStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetupForStreaming() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetupForStreaming(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetupForStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetupForStreaming(::grpc::ServerContext* /*context*/, const ::player::SetupForStreamingRequest* /*request*/, ::player::SetupForStreamingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetupForStreaming(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProcessTitle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ProcessTitle() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProcessTitle(context, request, response); }));
    }
    ~WithRawCallbackMethod_ProcessTitle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessTitle(::grpc::ServerContext* /*context*/, const ::player::ProcessTitleRequest* /*request*/, ::player::ProcessTitleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProcessTitle(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLink() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLink(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::player::GetLinkRequest* /*request*/, ::player::GetLinkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLink(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EndChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EndChan() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->EndChan(context, request); }));
    }
    ~WithRawCallbackMethod_EndChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EndChan(::grpc::ServerContext* /*context*/, const ::player::EndChanRequest* /*request*/, ::grpc::ServerWriter< ::player::EndChanReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* EndChan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_IsEnded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_IsEnded() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsEnded(context, request, response); }));
    }
    ~WithRawCallbackMethod_IsEnded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsEnded(::grpc::ServerContext* /*context*/, const ::player::IsEndedRequest* /*request*/, ::player::IsEndedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* IsEnded(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPosition() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPosition(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* /*context*/, const ::player::GetPositionRequest* /*request*/, ::player::GetPositionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLength() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLength(::grpc::ServerContext* /*context*/, const ::player::GetLengthRequest* /*request*/, ::player::GetLengthReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSpeed() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSpeed(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpeed(::grpc::ServerContext* /*context*/, const ::player::GetSpeedRequest* /*request*/, ::player::GetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSpeed() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSpeed(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSpeed(::grpc::ServerContext* /*context*/, const ::player::SetSpeedRequest* /*request*/, ::player::SetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSpeed(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPause() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPause(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPause(::grpc::ServerContext* /*context*/, const ::player::GetPauseRequest* /*request*/, ::player::GetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPause(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetPause() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPause(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPause(::grpc::ServerContext* /*context*/, const ::player::SetPauseRequest* /*request*/, ::player::SetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetPause(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Seek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Seek() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Seek(context, request, response); }));
    }
    ~WithRawCallbackMethod_Seek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Seek(::grpc::ServerContext* /*context*/, const ::player::SeekRequest* /*request*/, ::player::SeekReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Seek(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVideoTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVideoTracks() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVideoTracks(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVideoTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVideoTracks(::grpc::ServerContext* /*context*/, const ::player::GetVideoTracksRequest* /*request*/, ::player::GetVideoTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVideoTracks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAudioTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAudioTracks() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAudioTracks(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAudioTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAudioTracks(::grpc::ServerContext* /*context*/, const ::player::GetAudioTracksRequest* /*request*/, ::player::GetAudioTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAudioTracks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSubtitlesTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSubtitlesTracks() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSubtitlesTracks(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSubtitlesTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubtitlesTracks(::grpc::ServerContext* /*context*/, const ::player::GetSubtitlesTracksRequest* /*request*/, ::player::GetSubtitlesTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSubtitlesTracks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetVideoTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetVideoTrack() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVideoTrack(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetVideoTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVideoTrack(::grpc::ServerContext* /*context*/, const ::player::SetVideoTrackRequest* /*request*/, ::player::SetVideoTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVideoTrack(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAudioTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAudioTrack() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAudioTrack(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAudioTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAudioTrack(::grpc::ServerContext* /*context*/, const ::player::SetAudioTrackRequest* /*request*/, ::player::SetAudioTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAudioTrack(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetSubtitlesTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetSubtitlesTrack() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetSubtitlesTrack(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetSubtitlesTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetSubtitlesTrack(::grpc::ServerContext* /*context*/, const ::player::SetSubtitlesTrackRequest* /*request*/, ::player::SetSubtitlesTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetSubtitlesTrack(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Stop() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Stop(context, request, response); }));
    }
    ~WithRawCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::player::StopRequest* /*request*/, ::player::StopReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Close() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Close(context, request, response); }));
    }
    ~WithRawCallbackMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::player::CloseRequest* /*request*/, ::player::CloseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Close(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Open : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Open() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::OpenRequest, ::player::OpenReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::OpenRequest, ::player::OpenReply>* streamer) {
                       return this->StreamedOpen(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Open() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Open(::grpc::ServerContext* /*context*/, const ::player::OpenRequest* /*request*/, ::player::OpenReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOpen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::OpenRequest,::player::OpenReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetupForStreaming : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetupForStreaming() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::SetupForStreamingRequest, ::player::SetupForStreamingReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::SetupForStreamingRequest, ::player::SetupForStreamingReply>* streamer) {
                       return this->StreamedSetupForStreaming(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetupForStreaming() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetupForStreaming(::grpc::ServerContext* /*context*/, const ::player::SetupForStreamingRequest* /*request*/, ::player::SetupForStreamingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetupForStreaming(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::SetupForStreamingRequest,::player::SetupForStreamingReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProcessTitle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProcessTitle() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::ProcessTitleRequest, ::player::ProcessTitleReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::ProcessTitleRequest, ::player::ProcessTitleReply>* streamer) {
                       return this->StreamedProcessTitle(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProcessTitle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProcessTitle(::grpc::ServerContext* /*context*/, const ::player::ProcessTitleRequest* /*request*/, ::player::ProcessTitleReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProcessTitle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::ProcessTitleRequest,::player::ProcessTitleReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLink : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLink() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetLinkRequest, ::player::GetLinkReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetLinkRequest, ::player::GetLinkReply>* streamer) {
                       return this->StreamedGetLink(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLink() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLink(::grpc::ServerContext* /*context*/, const ::player::GetLinkRequest* /*request*/, ::player::GetLinkReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLink(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetLinkRequest,::player::GetLinkReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsEnded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsEnded() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::IsEndedRequest, ::player::IsEndedReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::IsEndedRequest, ::player::IsEndedReply>* streamer) {
                       return this->StreamedIsEnded(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsEnded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsEnded(::grpc::ServerContext* /*context*/, const ::player::IsEndedRequest* /*request*/, ::player::IsEndedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsEnded(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::IsEndedRequest,::player::IsEndedReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPosition() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetPositionRequest, ::player::GetPositionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetPositionRequest, ::player::GetPositionReply>* streamer) {
                       return this->StreamedGetPosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* /*context*/, const ::player::GetPositionRequest* /*request*/, ::player::GetPositionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetPositionRequest,::player::GetPositionReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLength() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetLengthRequest, ::player::GetLengthReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetLengthRequest, ::player::GetLengthReply>* streamer) {
                       return this->StreamedGetLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLength(::grpc::ServerContext* /*context*/, const ::player::GetLengthRequest* /*request*/, ::player::GetLengthReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetLengthRequest,::player::GetLengthReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSpeed() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetSpeedRequest, ::player::GetSpeedReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetSpeedRequest, ::player::GetSpeedReply>* streamer) {
                       return this->StreamedGetSpeed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSpeed(::grpc::ServerContext* /*context*/, const ::player::GetSpeedRequest* /*request*/, ::player::GetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSpeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetSpeedRequest,::player::GetSpeedReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSpeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSpeed() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::SetSpeedRequest, ::player::SetSpeedReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::SetSpeedRequest, ::player::SetSpeedReply>* streamer) {
                       return this->StreamedSetSpeed(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSpeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSpeed(::grpc::ServerContext* /*context*/, const ::player::SetSpeedRequest* /*request*/, ::player::SetSpeedReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSpeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::SetSpeedRequest,::player::SetSpeedReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPause() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetPauseRequest, ::player::GetPauseReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetPauseRequest, ::player::GetPauseReply>* streamer) {
                       return this->StreamedGetPause(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPause(::grpc::ServerContext* /*context*/, const ::player::GetPauseRequest* /*request*/, ::player::GetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPause(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetPauseRequest,::player::GetPauseReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPause() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::SetPauseRequest, ::player::SetPauseReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::SetPauseRequest, ::player::SetPauseReply>* streamer) {
                       return this->StreamedSetPause(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPause(::grpc::ServerContext* /*context*/, const ::player::SetPauseRequest* /*request*/, ::player::SetPauseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPause(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::SetPauseRequest,::player::SetPauseReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Seek : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Seek() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::SeekRequest, ::player::SeekReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::SeekRequest, ::player::SeekReply>* streamer) {
                       return this->StreamedSeek(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Seek() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Seek(::grpc::ServerContext* /*context*/, const ::player::SeekRequest* /*request*/, ::player::SeekReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSeek(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::SeekRequest,::player::SeekReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVideoTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVideoTracks() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetVideoTracksRequest, ::player::GetVideoTracksReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetVideoTracksRequest, ::player::GetVideoTracksReply>* streamer) {
                       return this->StreamedGetVideoTracks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVideoTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVideoTracks(::grpc::ServerContext* /*context*/, const ::player::GetVideoTracksRequest* /*request*/, ::player::GetVideoTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVideoTracks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetVideoTracksRequest,::player::GetVideoTracksReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAudioTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAudioTracks() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetAudioTracksRequest, ::player::GetAudioTracksReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetAudioTracksRequest, ::player::GetAudioTracksReply>* streamer) {
                       return this->StreamedGetAudioTracks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAudioTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAudioTracks(::grpc::ServerContext* /*context*/, const ::player::GetAudioTracksRequest* /*request*/, ::player::GetAudioTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAudioTracks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetAudioTracksRequest,::player::GetAudioTracksReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSubtitlesTracks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSubtitlesTracks() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::GetSubtitlesTracksRequest, ::player::GetSubtitlesTracksReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::GetSubtitlesTracksRequest, ::player::GetSubtitlesTracksReply>* streamer) {
                       return this->StreamedGetSubtitlesTracks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSubtitlesTracks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSubtitlesTracks(::grpc::ServerContext* /*context*/, const ::player::GetSubtitlesTracksRequest* /*request*/, ::player::GetSubtitlesTracksReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSubtitlesTracks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::GetSubtitlesTracksRequest,::player::GetSubtitlesTracksReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVideoTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVideoTrack() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::SetVideoTrackRequest, ::player::SetVideoTrackReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::SetVideoTrackRequest, ::player::SetVideoTrackReply>* streamer) {
                       return this->StreamedSetVideoTrack(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVideoTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVideoTrack(::grpc::ServerContext* /*context*/, const ::player::SetVideoTrackRequest* /*request*/, ::player::SetVideoTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVideoTrack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::SetVideoTrackRequest,::player::SetVideoTrackReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAudioTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAudioTrack() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::SetAudioTrackRequest, ::player::SetAudioTrackReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::SetAudioTrackRequest, ::player::SetAudioTrackReply>* streamer) {
                       return this->StreamedSetAudioTrack(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAudioTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAudioTrack(::grpc::ServerContext* /*context*/, const ::player::SetAudioTrackRequest* /*request*/, ::player::SetAudioTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAudioTrack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::SetAudioTrackRequest,::player::SetAudioTrackReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetSubtitlesTrack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetSubtitlesTrack() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::SetSubtitlesTrackRequest, ::player::SetSubtitlesTrackReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::SetSubtitlesTrackRequest, ::player::SetSubtitlesTrackReply>* streamer) {
                       return this->StreamedSetSubtitlesTrack(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetSubtitlesTrack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetSubtitlesTrack(::grpc::ServerContext* /*context*/, const ::player::SetSubtitlesTrackRequest* /*request*/, ::player::SetSubtitlesTrackReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetSubtitlesTrack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::SetSubtitlesTrackRequest,::player::SetSubtitlesTrackReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Stop() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::StopRequest, ::player::StopReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::StopRequest, ::player::StopReply>* streamer) {
                       return this->StreamedStop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::player::StopRequest* /*request*/, ::player::StopReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::StopRequest,::player::StopReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Close : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Close() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::player::CloseRequest, ::player::CloseReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::player::CloseRequest, ::player::CloseReply>* streamer) {
                       return this->StreamedClose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Close() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Close(::grpc::ServerContext* /*context*/, const ::player::CloseRequest* /*request*/, ::player::CloseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::player::CloseRequest,::player::CloseReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_SetupForStreaming<WithStreamedUnaryMethod_ProcessTitle<WithStreamedUnaryMethod_GetLink<WithStreamedUnaryMethod_IsEnded<WithStreamedUnaryMethod_GetPosition<WithStreamedUnaryMethod_GetLength<WithStreamedUnaryMethod_GetSpeed<WithStreamedUnaryMethod_SetSpeed<WithStreamedUnaryMethod_GetPause<WithStreamedUnaryMethod_SetPause<WithStreamedUnaryMethod_Seek<WithStreamedUnaryMethod_GetVideoTracks<WithStreamedUnaryMethod_GetAudioTracks<WithStreamedUnaryMethod_GetSubtitlesTracks<WithStreamedUnaryMethod_SetVideoTrack<WithStreamedUnaryMethod_SetAudioTrack<WithStreamedUnaryMethod_SetSubtitlesTrack<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_Close<Service > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_EndChan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_EndChan() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::player::EndChanRequest, ::player::EndChanReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::player::EndChanRequest, ::player::EndChanReply>* streamer) {
                       return this->StreamedEndChan(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_EndChan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EndChan(::grpc::ServerContext* /*context*/, const ::player::EndChanRequest* /*request*/, ::grpc::ServerWriter< ::player::EndChanReply>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedEndChan(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::player::EndChanRequest,::player::EndChanReply>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_EndChan<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Open<WithStreamedUnaryMethod_SetupForStreaming<WithStreamedUnaryMethod_ProcessTitle<WithStreamedUnaryMethod_GetLink<WithSplitStreamingMethod_EndChan<WithStreamedUnaryMethod_IsEnded<WithStreamedUnaryMethod_GetPosition<WithStreamedUnaryMethod_GetLength<WithStreamedUnaryMethod_GetSpeed<WithStreamedUnaryMethod_SetSpeed<WithStreamedUnaryMethod_GetPause<WithStreamedUnaryMethod_SetPause<WithStreamedUnaryMethod_Seek<WithStreamedUnaryMethod_GetVideoTracks<WithStreamedUnaryMethod_GetAudioTracks<WithStreamedUnaryMethod_GetSubtitlesTracks<WithStreamedUnaryMethod_SetVideoTrack<WithStreamedUnaryMethod_SetAudioTrack<WithStreamedUnaryMethod_SetSubtitlesTrack<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_Close<Service > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace player


#endif  // GRPC_player_2eproto__INCLUDED
